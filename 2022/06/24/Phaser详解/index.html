<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Phaser详解 | 王鹏宇的博客</title><meta name="description" content="Phaser运行机制  Registration(注册)  跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化。任务可以随时注册(使用方法register,bulkRegister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveAndDeregister)。就像大多数基本的同步结构一样，注册和撤销只影响内部count"><meta name="keywords" content="Java,多线程工具"><meta name="author" content="Wangpengyu"><meta name="copyright" content="Wangpengyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/24/Phaser%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="Phaser详解"><meta property="og:url" content="http://example.com/2022/06/24/Phaser%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="王鹏宇的博客"><meta property="og:description" content="Phaser运行机制  Registration(注册)  跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化。任务可以随时注册(使用方法register,bulkRegister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveAndDeregister)。就像大多数基本的同步结构一样，注册和撤销只影响内部count"><meta property="og:image" content="http://example.com/blogImg/Phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png"><meta property="article:published_time" content="2022-06-24T03:52:51.000Z"><meta property="article:modified_time" content="2023-07-02T07:40:17.033Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-07-02 15:40:17'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">126</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">53</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">27</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">Phaser运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Phaser%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">Phaser源码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">函数列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-register"><span class="toc-number">2.3.</span> <span class="toc-text">方法 - register()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-arrive"><span class="toc-number">2.4.</span> <span class="toc-text">方法 - arrive()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-arriveAndAwaitAdvance"><span class="toc-number">2.5.</span> <span class="toc-text">方法 - arriveAndAwaitAdvance()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-awaitAdvance-int-phase"><span class="toc-number">2.6.</span> <span class="toc-text">方法 - awaitAdvance(int phase)</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/blogImg/Phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王鹏宇的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Phaser详解</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-24T03:52:51.000Z" title="发表于 2022-06-24 11:52:51">2022-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-02T07:40:17.033Z" title="更新于 2023-07-02 15:40:17">2023-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7/">多线程工具</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Phaser运行机制"><a href="#Phaser运行机制" class="headerlink" title="Phaser运行机制"></a>Phaser运行机制</h2><p><img src="/blogImg/Phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="Phaser运行机制"></p>
<ul>
<li><strong>Registration(注册)</strong></li>
</ul>
<p>跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化。任务可以随时注册(使用方法register,bulkRegister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveAndDeregister)。就像大多数基本的同步结构一样，注册和撤销只影响内部count；不会创建更深的内部记录，所以任务不能查询他们是否已经注册。(不过，可以通过继承来实现类似的记录)</p>
<ul>
<li><strong>Synchronization(同步机制)</strong></li>
</ul>
<p>和CyclicBarrier一样，Phaser也可以重复await。方法arriveAndAwaitAdvance的效果类似CyclicBarrier.await。phaser的每一代都有一个相关的phase number，初始值为0，当所有注册的任务都到达phaser时phase+1，到达最大值(Integer.MAX_VALUE)之后清零。使用phase number可以独立控制 到达phaser 和 等待其他线程 的动作，通过下面两种类型的方法:</p>
<blockquote>
<ul>
<li><strong>Arrival(到达机制)</strong> arrive和arriveAndDeregister方法记录到达状态。这些方法不会阻塞，但是会返回一个相关的arrival phase number；也就是说，phase number用来确定到达状态。当所有任务都到达给定phase时，可以执行一个可选的函数，这个函数通过重写onAdvance方法实现，通常可以用来控制终止状态。重写此方法类似于为CyclicBarrier提供一个barrierAction，但比它更灵活。</li>
<li><strong>Waiting(等待机制)</strong> awaitAdvance方法需要一个表示arrival phase number的参数，并且在phaser前进到与给定phase不同的phase时返回。和CyclicBarrier不同，即使等待线程已经被中断，awaitAdvance方法也会一直等待。中断状态和超时时间同样可用，但是当任务等待中断或超时后未改变phaser的状态时会遭遇异常。如果有必要，在方法forceTermination之后可以执行这些异常的相关的handler进行恢复操作，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务。</li>
</ul>
</blockquote>
<ul>
<li><strong>Termination(终止机制)</strong> :</li>
</ul>
<p>可以用isTerminated方法检查phaser的终止状态。在终止时，所有同步方法立刻返回一个负值。在终止时尝试注册也没有效果。当调用onAdvance返回true时Termination被触发。当deregistration操作使已注册的parties变为0时，onAdvance的默认实现就会返回true。也可以重写onAdvance方法来定义终止动作。forceTermination方法也可以释放等待线程并且允许它们终止。</p>
<ul>
<li><strong>Tiering(分层结构)</strong> :</li>
</ul>
<p>Phaser支持分层结构(树状构造)来减少竞争。注册了大量parties的Phaser可能会因为同步竞争消耗很高的成本， 因此可以设置一些子Phaser来共享一个通用的parent。这样的话即使每个操作消耗了更多的开销，但是会提高整体吞吐量。 在一个分层结构的phaser里，子节点phaser的注册和取消注册都通过父节点管理。子节点phaser通过构造或方法register、bulkRegister进行首次注册时，在其父节点上注册。子节点phaser通过调用arriveAndDeregister进行最后一次取消注册时，也在其父节点上取消注册。</p>
<ul>
<li><strong>Monitoring(状态监控)</strong> :</li>
</ul>
<p>由于同步方法可能只被已注册的parties调用，所以phaser的当前状态也可能被任何调用者监控。在任何时候，可以通过getRegisteredParties获取parties数，其中getArrivedParties方法返回已经到达当前phase的parties数。当剩余的parties(通过方法getUnarrivedParties获取)到达时，phase进入下一代。这些方法返回的值可能只表示短暂的状态，所以一般来说在同步结构里并没有啥卵用。</p>
<h2 id="Phaser源码详解"><a href="#Phaser源码详解" class="headerlink" title="Phaser源码详解"></a>Phaser源码详解</h2><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The parent of this phaser, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser parent;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root of phaser tree. Equals this if not in a tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Phaser root;</span><br><span class="line"><span class="comment">//等待线程的栈顶元素，根据phase取模定义为一个奇数header和一个偶数header</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; evenQ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;QNode&gt; oddQ;</span><br></pre></td></tr></table></figure>

<p>state状态说明:</p>
<p>Phaser使用一个long型state值来标识内部状态:</p>
<ul>
<li>低0-15位表示未到达parties数；</li>
<li>中16-31位表示等待的parties数；</li>
<li>中32-62位表示phase当前代；</li>
<li>高63位表示当前phaser的终止状态。</li>
</ul>
<p>注意: 子Phaser的phase在没有被真正使用之前，允许滞后于它的root节点。这里在后面源码分析的reconcileState方法里会讲解。 Qnode是Phaser定义的内部等待队列，用于在阻塞时记录等待线程及相关信息。实现了ForkJoinPool的一个内部接口ManagedBlocker，上面已经说过，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务(通过内部实现方法isReleasable和block)。</p>
<h3 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, parties);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parent, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Phaser</span><span class="params">(Phaser parent, <span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注册一个新的party</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//批量注册</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulkRegister</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrive</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程到达phaser并撤销注册，返回arrival phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndDeregister</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 使当前线程到达phaser并等待其他任务到达，等价于awaitAdvance(arrive())。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果需要等待中断或超时，可以使用awaitAdvance方法完成一个类似的构造。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果需要在到达后取消注册，可以使用awaitAdvance(arriveAndDeregister())。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//等待给定phase数，返回下一个 arrival phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span></span></span><br><span class="line"><span class="function"><span class="comment">//阻塞等待，直到phase前进到下一代，返回下一代的phase number</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//响应中断版awaitAdvance</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function"><span class="comment">//使当前phaser进入终止状态，已注册的parties不受影响，如果是分层结构，则终止所有phaser</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceTermination</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="方法-register"><a href="#方法-register" class="headerlink" title="方法 - register()"></a>方法 - register()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个新的party</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRegister(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRegister</span><span class="params">(<span class="keyword">int</span> registrations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// adjustment to state</span></span><br><span class="line">    <span class="keyword">long</span> adjust = ((<span class="keyword">long</span>)registrations &lt;&lt; PARTIES_SHIFT) | registrations;</span><br><span class="line">    <span class="keyword">final</span> Phaser parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (parent == <span class="keyword">null</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> parties = counts &gt;&gt;&gt; PARTIES_SHIFT;<span class="comment">//获取已注册parties数</span></span><br><span class="line">        <span class="keyword">int</span> unarrived = counts &amp; UNARRIVED_MASK;<span class="comment">//未到达数</span></span><br><span class="line">        <span class="keyword">if</span> (registrations &gt; MAX_PARTIES - parties)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badRegister(s));</span><br><span class="line">        phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);<span class="comment">//获取当前代</span></span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (counts != EMPTY) &#123;                  <span class="comment">// not 1st registration</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span> || reconcileState() == s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unarrived == <span class="number">0</span>)             <span class="comment">// wait out advance</span></span><br><span class="line">                    root.internalAwaitAdvance(phase, <span class="keyword">null</span>);<span class="comment">//等待其他任务到达</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                                   s, s + adjust))<span class="comment">//更新注册的parties数</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;              <span class="comment">// 1st root registration</span></span><br><span class="line">            <span class="keyword">long</span> next = ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, next))<span class="comment">//更新phase</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分层结构，子phaser首次注册用父节点管理</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;               <span class="comment">// 1st sub registration</span></span><br><span class="line">                <span class="keyword">if</span> (state == s) &#123;               <span class="comment">// recheck under lock</span></span><br><span class="line">                    phase = parent.doRegister(<span class="number">1</span>);<span class="comment">//分层结构，使用父节点注册</span></span><br><span class="line">                    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// finish registration whenever parent registration</span></span><br><span class="line">                    <span class="comment">// succeeded, even when racing with termination,</span></span><br><span class="line">                    <span class="comment">// since these are part of the same &quot;transaction&quot;.</span></span><br><span class="line">                    <span class="comment">//由于在同一个事务里，即使phaser已终止，也会完成注册</span></span><br><span class="line">                    <span class="keyword">while</span> (!UNSAFE.compareAndSwapLong</span><br><span class="line">                           (<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                            ((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) | adjust)) &#123;<span class="comment">//更新phase</span></span><br><span class="line">                        s = state;</span><br><span class="line">                        phase = (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">                        <span class="comment">// assert (int)s == EMPTY;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> phase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: register方法为phaser添加一个新的party，如果onAdvance正在运行，那么这个方法会等待它运行结束再返回结果。如果当前phaser有父节点，并且当前phaser上没有已注册的party，那么就会交给父节点注册。</p>
<p>register和bulkRegister都由doRegister实现，大概流程如下:</p>
<ul>
<li>如果当前操作不是首次注册，那么直接在当前phaser上更新注册parties数</li>
<li>如果是首次注册，并且当前phaser没有父节点，说明是root节点注册，直接更新phase</li>
<li>如果当前操作是首次注册，并且当前phaser由父节点，则注册操作交由父节点，并更新当前phaser的phase</li>
<li>上面说过，子Phaser的phase在没有被真正使用之前，允许滞后于它的root节点。非首次注册时，如果Phaser有父节点，则调用reconcileState()方法解决root节点的phase延迟传递问题， 源码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">reconcileState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> phase, p;</span><br><span class="line">        <span class="comment">// CAS to root phase with current parties, tripping unarrived</span></span><br><span class="line">        <span class="keyword">while</span> ((phase = (<span class="keyword">int</span>)(root.state &gt;&gt;&gt; PHASE_SHIFT)) !=</span><br><span class="line">               (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT) &amp;&amp;</span><br><span class="line">               !UNSAFE.compareAndSwapLong</span><br><span class="line">               (<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                s = (((<span class="keyword">long</span>)phase &lt;&lt; PHASE_SHIFT) |</span><br><span class="line">                     ((phase &lt; <span class="number">0</span>) ? (s &amp; COUNTS_MASK) :</span><br><span class="line">                      (((p = (<span class="keyword">int</span>)s &gt;&gt;&gt; PARTIES_SHIFT) == <span class="number">0</span>) ? EMPTY :</span><br><span class="line">                       ((s &amp; PARTIES_MASK) | p))))))</span><br><span class="line">            s = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当root节点的phase已经advance到下一代，但是子节点phaser还没有，这种情况下它们必须通过更新未到达parties数 完成它们自己的advance操作(如果parties为0，重置为EMPTY状态)。</p>
<p>回到register方法的第一步，如果当前未到达数为0，说明上一代phase正在进行到达操作，此时调用internalAwaitAdvance()方法等待其他任务完成到达操作，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞等待phase到下一代</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">internalAwaitAdvance</span><span class="params">(<span class="keyword">int</span> phase, QNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert root == this;</span></span><br><span class="line">    releaseWaiters(phase-<span class="number">1</span>);          <span class="comment">// ensure old queue clean</span></span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;           <span class="comment">// true when node is enqueued</span></span><br><span class="line">    <span class="keyword">int</span> lastUnarrived = <span class="number">0</span>;            <span class="comment">// to increase spins upon change</span></span><br><span class="line">    <span class="keyword">int</span> spins = SPINS_PER_ARRIVAL;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">while</span> ((p = (<span class="keyword">int</span>)((s = state) &gt;&gt;&gt; PHASE_SHIFT)) == phase) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;           <span class="comment">// spinning in noninterruptible mode</span></span><br><span class="line">            <span class="keyword">int</span> unarrived = (<span class="keyword">int</span>)s &amp; UNARRIVED_MASK;<span class="comment">//未到达数</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived != lastUnarrived &amp;&amp;</span><br><span class="line">                (lastUnarrived = unarrived) &lt; NCPU)</span><br><span class="line">                spins += SPINS_PER_ARRIVAL;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = Thread.interrupted();</span><br><span class="line">            <span class="keyword">if</span> (interrupted || --spins &lt; <span class="number">0</span>) &#123; <span class="comment">// need node to record intr</span></span><br><span class="line">                <span class="comment">//使用node记录中断状态</span></span><br><span class="line">                node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">                node.wasInterrupted = interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.isReleasable()) <span class="comment">// done or aborted</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued) &#123;           <span class="comment">// push onto queue</span></span><br><span class="line">            AtomicReference&lt;QNode&gt; head = (phase &amp; <span class="number">1</span>) == <span class="number">0</span> ? evenQ : oddQ;</span><br><span class="line">            QNode q = node.next = head.get();</span><br><span class="line">            <span class="keyword">if</span> ((q == <span class="keyword">null</span> || q.phase == phase) &amp;&amp;</span><br><span class="line">                (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT) == phase) <span class="comment">// avoid stale enq</span></span><br><span class="line">                queued = head.compareAndSet(q, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ForkJoinPool.managedBlock(node);<span class="comment">//阻塞给定node</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                node.wasInterrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.thread != <span class="keyword">null</span>)</span><br><span class="line">            node.thread = <span class="keyword">null</span>;       <span class="comment">// avoid need for unpark()</span></span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted &amp;&amp; !node.interruptible)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">if</span> (p == phase &amp;&amp; (p = (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT)) == phase)</span><br><span class="line">            <span class="keyword">return</span> abortWait(phase); <span class="comment">// possibly clean up on abort</span></span><br><span class="line">    &#125;</span><br><span class="line">    releaseWaiters(phase);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单介绍下第二个参数node，如果不为空，则说明等待线程需要追踪中断状态或超时状态。以doRegister中的调用为例，不考虑线程争用，internalAwaitAdvance大概流程如下:</p>
<ul>
<li>首先调用releaseWaiters唤醒上一代所有等待线程，确保旧队列中没有遗留的等待线程。</li>
<li>循环SPINS_PER_ARRIVAL指定的次数或者当前线程被中断，创建node记录等待线程及相关信息。</li>
<li>继续循环调用ForkJoinPool.managedBlock运行被阻塞的任务</li>
<li>继续循环，阻塞任务运行成功被释放，跳出循环</li>
<li>最后唤醒当前phase的线程</li>
</ul>
<h3 id="方法-arrive"><a href="#方法-arrive" class="headerlink" title="方法 - arrive()"></a>方法 - arrive()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使当前线程到达phaser，不等待其他任务到达。返回arrival phase number</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doArrive(ONE_ARRIVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doArrive</span><span class="params">(<span class="keyword">int</span> adjust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="comment">//获取未到达数</span></span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK);</span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, s-=adjust)) &#123;<span class="comment">//更新state</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived == <span class="number">1</span>) &#123;<span class="comment">//当前为最后一个未到达的任务</span></span><br><span class="line">                <span class="keyword">long</span> n = s &amp; PARTIES_MASK;  <span class="comment">// base of next state</span></span><br><span class="line">                <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onAdvance(phase, nextUnarrived))<span class="comment">//检查是否需要终止phaser</span></span><br><span class="line">                        n |= TERMINATION_BIT;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                        n |= EMPTY;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        n |= nextUnarrived;</span><br><span class="line">                    <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE;</span><br><span class="line">                    n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">                    UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n);</span><br><span class="line">                    releaseWaiters(phase);<span class="comment">//释放等待phase的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//分层结构，使用父节点管理arrive</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>) &#123; <span class="comment">//propagate deregistration</span></span><br><span class="line">                    phase = parent.doArrive(ONE_DEREGISTER);</span><br><span class="line">                    UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset,</span><br><span class="line">                                              s, s | EMPTY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    phase = parent.doArrive(ONE_ARRIVAL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: arrive方法手动调整到达数，使当前线程到达phaser。arrive和arriveAndDeregister都调用了doArrive实现，大概流程如下:</p>
<ul>
<li>首先更新state(state - adjust)；</li>
<li>如果当前不是最后一个未到达的任务，直接返回phase</li>
<li>如果当前是最后一个未到达的任务: <ul>
<li>如果当前是root节点，判断是否需要终止phaser，CAS更新phase，最后释放等待的线程；</li>
<li>如果是分层结构，并且已经没有下一代未到达的parties，则交由父节点处理doArrive逻辑，然后更新state为EMPTY。</li>
</ul>
</li>
</ul>
<h3 id="方法-arriveAndAwaitAdvance"><a href="#方法-arriveAndAwaitAdvance" class="headerlink" title="方法 - arriveAndAwaitAdvance()"></a>方法 - arriveAndAwaitAdvance()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arriveAndAwaitAdvance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Specialization of doArrive+awaitAdvance eliminating some reads/paths</span></span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">        <span class="keyword">int</span> phase = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">        <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> phase;</span><br><span class="line">        <span class="keyword">int</span> counts = (<span class="keyword">int</span>)s;</span><br><span class="line">        <span class="keyword">int</span> unarrived = (counts == EMPTY) ? <span class="number">0</span> : (counts &amp; UNARRIVED_MASK);<span class="comment">//获取未到达数</span></span><br><span class="line">        <span class="keyword">if</span> (unarrived &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(badArrive(s));</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s,</span><br><span class="line">                                      s -= ONE_ARRIVAL)) &#123;<span class="comment">//更新state</span></span><br><span class="line">            <span class="keyword">if</span> (unarrived &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);<span class="comment">//阻塞等待其他任务</span></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> parent.arriveAndAwaitAdvance();<span class="comment">//子Phaser交给父节点处理</span></span><br><span class="line">            <span class="keyword">long</span> n = s &amp; PARTIES_MASK;  <span class="comment">// base of next state</span></span><br><span class="line">            <span class="keyword">int</span> nextUnarrived = (<span class="keyword">int</span>)n &gt;&gt;&gt; PARTIES_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (onAdvance(phase, nextUnarrived))<span class="comment">//全部到达，检查是否可销毁</span></span><br><span class="line">                n |= TERMINATION_BIT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nextUnarrived == <span class="number">0</span>)</span><br><span class="line">                n |= EMPTY;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                n |= nextUnarrived;</span><br><span class="line">            <span class="keyword">int</span> nextPhase = (phase + <span class="number">1</span>) &amp; MAX_PHASE;<span class="comment">//计算下一代phase</span></span><br><span class="line">            n |= (<span class="keyword">long</span>)nextPhase &lt;&lt; PHASE_SHIFT;</span><br><span class="line">            <span class="keyword">if</span> (!UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, s, n))<span class="comment">//更新state</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)(state &gt;&gt;&gt; PHASE_SHIFT); <span class="comment">// terminated</span></span><br><span class="line">            releaseWaiters(phase);<span class="comment">//释放等待phase的线程</span></span><br><span class="line">            <span class="keyword">return</span> nextPhase;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 使当前线程到达phaser并等待其他任务到达，等价于awaitAdvance(arrive())。如果需要等待中断或超时，可以使用awaitAdvance方法完成一个类似的构造。如果需要在到达后取消注册，可以使用awaitAdvance(arriveAndDeregister())。效果类似于CyclicBarrier.await。大概流程如下:</p>
<ul>
<li>更新state(state - 1)；</li>
<li>如果未到达数大于1，调用internalAwaitAdvance阻塞等待其他任务到达，返回当前phase</li>
<li>如果为分层结构，则交由父节点处理arriveAndAwaitAdvance逻辑</li>
<li>如果未到达数&lt;=1，判断phaser终止状态，CAS更新phase到下一代，最后释放等待当前phase的线程，并返回下一代phase。</li>
</ul>
<h3 id="方法-awaitAdvance-int-phase"><a href="#方法-awaitAdvance-int-phase" class="headerlink" title="方法 - awaitAdvance(int phase)"></a>方法 - awaitAdvance(int phase)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvance</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase)</span><br><span class="line">        <span class="keyword">return</span> root.internalAwaitAdvance(phase, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应中断版awaitAdvance</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">awaitAdvanceInterruptibly</span><span class="params">(<span class="keyword">int</span> phase)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Phaser root = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">long</span> s = (root == <span class="keyword">this</span>) ? state : reconcileState();</span><br><span class="line">    <span class="keyword">int</span> p = (<span class="keyword">int</span>)(s &gt;&gt;&gt; PHASE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (phase &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> phase;</span><br><span class="line">    <span class="keyword">if</span> (p == phase) &#123;</span><br><span class="line">        QNode node = <span class="keyword">new</span> QNode(<span class="keyword">this</span>, phase, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        p = root.internalAwaitAdvance(phase, node);</span><br><span class="line">        <span class="keyword">if</span> (node.wasInterrupted)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: awaitAdvance用于阻塞等待线程到达，直到phase前进到下一代，返回下一代的phase number。方法很简单，不多赘述。awaitAdvanceInterruptibly方法是响应中断版的awaitAdvance，不同之处在于，调用阻塞时会记录线程的中断状态。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7/">多线程工具</a></div><div class="post_share"><div class="social-share" data-image="/blogImg/Phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/Wechatpay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/Wechatpay.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/24/Exchanger%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src="/img/jump.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Exchanger详解</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/23/Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="/blogImg/Fork:Join%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Fork/Join框架详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/13/FutureTask详解/" title="FutureTask详解"><img class="cover" src="/blogImg/FutureTask%E7%B1%BB%E5%85%B3%E7%B3%BB.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">FutureTask详解</div></div></a></div><div><a href="/2022/05/13/ScheduledThreadPoolExecutor详解/" title="ScheduledThreadPoolExecutor详解"><img class="cover" src="/blogImg/ScheduledThreadPoolExecutor%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">ScheduledThreadPoolExecutor详解</div></div></a></div><div><a href="/2022/05/13/ThreadPoolExecutor详解/" title="ThreadPoolExecutor详解"><img class="cover" src="/blogImg/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">ThreadPoolExecutor详解</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Wangpengyu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'silence314/commit-utterances')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>