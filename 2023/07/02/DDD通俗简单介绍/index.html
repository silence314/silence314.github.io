<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>DDD通俗简单介绍 | 王鹏宇的博客</title><meta name="description" content="面向对象和面向过程面向过程是最为实际的一种思考方式，就算是面向对象的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。当程序规模不是很大时，面向过程的方法还会体现出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。 面向对象是基于对象概念，以对象为中心，以类和继承为构造机制，"><meta name="keywords" content="设计模式"><meta name="author" content="Wangpengyu"><meta name="copyright" content="Wangpengyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/02/DDD%E9%80%9A%E4%BF%97%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="DDD通俗简单介绍"><meta property="og:url" content="http://example.com/2023/07/02/DDD%E9%80%9A%E4%BF%97%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"><meta property="og:site_name" content="王鹏宇的博客"><meta property="og:description" content="面向对象和面向过程面向过程是最为实际的一种思考方式，就算是面向对象的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。当程序规模不是很大时，面向过程的方法还会体现出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。 面向对象是基于对象概念，以对象为中心，以类和继承为构造机制，"><meta property="og:image" content="http://example.com/img/jump.png"><meta property="article:published_time" content="2023-07-02T05:26:58.000Z"><meta property="article:modified_time" content="2023-07-02T05:56:13.331Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-07-02 13:56:13'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">126</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">53</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">27</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">面向对象和面向过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-number">1.1.</span> <span class="toc-text">优缺点比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">面向过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">面向对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DDD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">DDD是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">关键概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F"><span class="toc-number">3.1.</span> <span class="toc-text">领域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%9F%9F"><span class="toc-number">3.2.</span> <span class="toc-text">子域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%9F%9F"><span class="toc-number">3.3.</span> <span class="toc-text">核心域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9F%9F"><span class="toc-number">3.4.</span> <span class="toc-text">通用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%92%91%E5%9F%9F"><span class="toc-number">3.5.</span> <span class="toc-text">支撑域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.6.</span> <span class="toc-text">领域事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.7.</span> <span class="toc-text">领域服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.8.</span> <span class="toc-text">应用服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.9.</span> <span class="toc-text">限界上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93"><span class="toc-number">3.10.</span> <span class="toc-text">实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.11.</span> <span class="toc-text">值对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repositories"><span class="toc-number">3.12.</span> <span class="toc-text">Repositories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E8%85%90%E5%B1%82"><span class="toc-number">3.13.</span> <span class="toc-text">防腐层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">3.14.</span> <span class="toc-text">聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%A0%B9"><span class="toc-number">3.15.</span> <span class="toc-text">聚合根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4"><span class="toc-number">3.16.</span> <span class="toc-text">事件风暴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.17.</span> <span class="toc-text">贫血模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.18.</span> <span class="toc-text">充血模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-number">3.18.1.</span> <span class="toc-text">对比分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CURS%EF%BC%9A"><span class="toc-number">3.19.</span> <span class="toc-text">CURS：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E5%88%B0%E5%88%86%E6%8B%A3%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">对应到分拣的例子：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A7%E5%B7%A5%E7%A8%8B%E5%92%8CDDD"><span class="toc-number">5.</span> <span class="toc-text">旧工程和DDD</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/jump.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王鹏宇的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">DDD通俗简单介绍</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-02T05:26:58.000Z" title="发表于 2023-07-02 13:26:58">2023-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-02T05:56:13.331Z" title="更新于 2023-07-02 13:56:13">2023-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p>面向过程是最为实际的一种思考方式，就算是面向对象的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。当程序规模不是很大时，面向过程的方法还会体现出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。</p>
<p>面向对象是基于对象概念，以对象为中心，以类和继承为构造机制，来认识、理解、刻画客观世界和设计、构建相应的软件系统。类和继承是是适应人们一般思维方式的描述范式。方法是允许作用于该类对象上的各种操作。这种对象、类、消息和方法的程序设计范式的基本点在于对象的封装性和类的继承性。通过封装能将对象的定义和对象的实现分开，通过继承能体现类与类之间的关系，以及由此带来的动态联编和实体的多态性。</p>
<h3 id="优缺点比较"><a href="#优缺点比较" class="headerlink" title="优缺点比较"></a>优缺点比较</h3><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><p>优点：</p>
<ul>
<li>流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。</li>
<li>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。</li>
</ul>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>优点:</p>
<ul>
<li><p>结构清晰，程序是模块化和结构化，更加符合人类的思维方式；</p>
</li>
<li><p>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；</p>
</li>
<li><p>易维护，系统低耦合的特点有利于减少程序的后期维护工作量。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。</p>
</li>
<li><p>性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</p>
</li>
</ul>
<h2 id="DDD是什么"><a href="#DDD是什么" class="headerlink" title="DDD是什么"></a>DDD是什么</h2><p>在我们习惯了J2EE的开发模式后，Action/Service/DAO这种分层模式，会很自然地写出过程式代码，而学到的很多关于OO理论的也毫无用武之地。使用这种开发方式，对象只是数据的载体，没有行为。以数据为中心，以数据库ER设计作驱动。分层架构在这种开发模式下，可以理解为是对数据移动、处理和实现的过程。</p>
<p>我理解的DDD和OO的差别：DDD是引入了<strong>限界上下文</strong>与<strong>聚合</strong>的面向对象<strong>，感觉可以理解为把调度、执行、逆向、交接这种业务领域划分的思维引入了单个服务的架构中。</strong></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a><strong>关键概念</strong></h2><h3 id="领域"><a href="#领域" class="headerlink" title="领域"></a><strong>领域</strong></h3><p>现实世界中，领域包含了问题域和解系统。一般认为软件是对现实世界的部分模拟。比如调度、执行</p>
<h3 id="子域"><a href="#子域" class="headerlink" title="子域"></a><strong>子域</strong></h3><p>相对的一个概念，我们可以将领域进行进一步的划分 ，这时候就是子域。比如任务转换</p>
<h3 id="核心域"><a href="#核心域" class="headerlink" title="核心域"></a><strong>核心域</strong></h3><p>所有领域中最关键的部分，就是最核心的部分，对于业务来说，核心域是企业根本竞争力。</p>
<h3 id="通用域"><a href="#通用域" class="headerlink" title="通用域"></a><strong>通用域</strong></h3><p>例如鉴权、日志等，特点是可能被多个领域公用的部分。</p>
<h3 id="支撑域"><a href="#支撑域" class="headerlink" title="支撑域"></a><strong>支撑域</strong></h3><p>系统中业务分析阶段最不重点关注的领域，也就是非核心域非通用域的领域，例如打印，仅仅是为了支撑业务的运转而存在，这类的领域就是支撑域。</p>
<p><img src="/blogImg/%E9%A2%86%E5%9F%9F.jpg" alt="领域"></p>
<h3 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a><strong>领域事件</strong></h3><p>领域事件是在领域内发生时需要有进一步业务操作的事件。比如逆向出库登记完进行交接</p>
<h3 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a><strong>领域服务</strong></h3><p>领域服务就是那些和实体具有交互，但是不完全属于单个实体或者聚合的服务，这种一般会抽象为领域服务。比如任务转换，任务领取</p>
<h3 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a><strong>应用服务</strong></h3><p>与具体的业务逻辑无关，且在整个系统中，可能会被诸多服务调用（以便于重用），因此可以认为这些关注点为横切关注点，与横切关注点协作的服务应被定义为应用服务<strong>；</strong>不包含领域逻辑的业务服务应被定义为应用服务</p>
<p>领域服务和应用服务</p>
<ul>
<li>应用服务里不要处理业务逻辑，只在领域服务里处理业务逻辑。</li>
<li>领域服务掌握领域知识，而应用服务只是对领域服务的编排。</li>
<li>应用服务是领域服务的客户方，也就是说应用服务会调用领域服务里的方法。</li>
<li>当领域中的某个操作过程不属于实体或者值对象的职责时，需要将个操作放在领域服务中。而且确保<strong>领域服务是无状态的</strong>（这句话很有意思，也就是说领域服务中不应该有任何记录状态的行为，在任何情况下调用这个服务，它都不会有副作用，也就是说它是个纯内存操作）。</li>
<li>领域服务中包含的是业务逻辑，而应用服务关注的应该是安全和事务等非业务逻辑。</li>
<li>对事务的管理绝对不能放在领域服务层，事务管理需要放在应用服务层。因为和领域模型相关的操作的粒度都很细，无法用于事务管理。而且领域模型也不应该意识到事务的存在。</li>
<li>通常的可以放在应用服务中的逻辑有：参数验证、错误处理、监控日志、事务处理、认证与授权。</li>
</ul>
<h3 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a><strong>限界上下文</strong></h3><p>限界上下文定义领域模型的边界，每个领域模型都有自己的领域边界，在领域边界内即限界上下文。一个限界上下文封装了一个相对独立子领域的领域模型和服务。限界上下文地图描述了各个子领域之间的集成调用关系，这个定义和微服务的划分不谋而合，以提供业务能力为导向的、自治的、独立部署单元。</p>
<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a><strong>实体</strong></h3><p>具有业务属性和业务行为，携带唯一标识，带有生命周期的对象。</p>
<h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a><strong>值对象</strong></h3><p>只具有属性信息，不携带唯一标识的对象。</p>
<h3 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a><strong>Repositories</strong></h3><p>在基础层和领域层之间的一层仓储服务。通过这一层可以实现业务逻辑和基础层资源的依赖分离。在变更基础层数据库的时候，你只要替换仓储实现就可以了，上层核心业务逻辑不会受基础资源变更的影响。（DAO的核心价值是封装了拼接SQL、维护数据库连接、事务等琐碎的底层逻辑，让业务开发可以专注于写代码。但是在本质上，DAO的操作还是数据库操作，DAO的某个方法还是在直接操作数据库和数据模型）</p>
<h3 id="防腐层"><a href="#防腐层" class="headerlink" title="防腐层"></a><strong>防腐层</strong></h3><p>一个上下文通过一些适配和转换与另一个上下文交互。</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><strong>聚合</strong></h3><p>实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合。</p>
<h3 id="聚合根"><a href="#聚合根" class="headerlink" title="聚合根"></a><strong>聚合根</strong></h3><p>将实体和值对象组织在一起协同工作叫聚合。聚合根也叫做根实体，聚合之间通信通过聚合根来管理，以聚合根 ID 关联的方式接受外部任务和请求。也就是说，一个聚合内如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。聚合根一般对应到一个Repositories。</p>
<p><img src="/blogImg/%E8%81%9A%E5%90%88%E6%A0%B9.jpg" alt="聚合根"></p>
<h3 id="事件风暴"><a href="#事件风暴" class="headerlink" title="事件风暴"></a><strong>事件风暴</strong></h3><p><strong>首先将一个业务场景、系统功能等分为以下几个概念</strong></p>
<ul>
<li><strong>事件(Event)</strong>: 事件风暴中的核心概念，它代表了某一个<strong>「业务行为」</strong>，描述的形似为<strong>宾语+动词的过去式</strong>。例如: 「订单被提交」，「账户被锁定」，「商品已被发出」。</li>
<li><strong>命令(Command)</strong>: 既然有了<strong>事件</strong>必然有产生事件的对象，这就是<strong>命令</strong>。命令可以理解为是一个动作，执行了动作之后就会产生相应的事件。典型的动作描述可以是: 「取消订单」，「结账」等。、</li>
<li><strong>用户(User 或 Actor)</strong>: 同样的<strong>命令</strong>也是由对象执行的，这称之为<strong>用户</strong>。这里的用户一般是指自然人，例如一个电子购物网站的顾客。</li>
</ul>
<p>事件风暴的核心流程就是由<strong>用户</strong>执行了<strong>命令</strong>，从而产生了<strong>事件</strong>。基于这个<strong>事件</strong>的结果(后续会谈及)，与之前相同或是其他的<strong>用户</strong>会执行另一个<strong>命令</strong>，产生新类型的<strong>事件</strong>，以此类推。而顺序是按照业务逻辑而定的。简单的可以参考下面一个简单的示例:</p>
<ul>
<li><strong>规则(Policy)</strong>: 当产生<strong>事件</strong>时，需要进行某些业务相关的<strong>规则</strong>校验，例如订单提交后需要检查库存是否充足，客户的支付交易是否成功等。</li>
<li><strong>读模型(Read Model) 与页面布局(Screen Layout)</strong>: <strong>事件</strong>产生后的另一个结果往往是呈现在<strong>用户</strong>面前的系统界面，在这里我们使用<strong>页面布局</strong>进行展示。同时<strong>页面布局</strong>上会展现<strong>用户</strong>所关心的数据，例如，当<strong>用户</strong>执行「结账」的<strong>命令</strong>之后，生成了「购物车结算」<strong>事件</strong>，此时呈现在<strong>用户</strong>面前的应该是商品明细信息和总金额。这样的数据我们使用<strong>读模型</strong>表示。</li>
<li><strong>外部系统(System)</strong>: <strong>事件</strong>并不一定由<strong>命令</strong>产生，也可能由一个<strong>外部系统产生</strong>，例如一个第三方的支付系统会调用由你系统提供的回调接口，确认客户支付成功，由此产生一个「费用已支付」的<strong>事件</strong>。</li>
<li><strong>问题(Question) 与假设(Assumption)</strong>: 在讨论过程中各个参与人员可能会发生分歧，例如对于<strong>事件</strong>的定义，或是由哪个<strong>用户</strong>执行，或者是具体的<strong>规则</strong>是什么。此时如果无法在规定的时间之内达成统一意见(一般为 5 分钟)，作为<strong>问题</strong>，或是对某种情况的<strong>假设</strong>记录下来。</li>
<li><strong>聚合(Aggregate)</strong>: 当一个完整的业务流程通过上述方式写完之后，对于每个<strong>用户，命令，事件</strong>进行组合，我们就能获得<strong>聚合</strong>了，用事件风暴的描述就是「用户在 XX 聚合对象上执行了 YY 命令，生成了 ZZ 事件」。例如「分拣员在分拣任务对象上执行了领取命令，生成了分拣任务领取事件」</li>
</ul>
<p>最后将获得完整的业务流程分析</p>
<h3 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a><strong>贫血模型</strong></h3><p>贫血模型是指领域对象里只有get和set方法，所有的业务逻辑都不包含在内。</p>
<p><strong>优点</strong></p>
<p>1、各层单向依赖，结构清楚，易于实现和维护。</p>
<p>2、设计简单易行，底层模型非常稳定。</p>
<p><strong>缺点</strong></p>
<p>1、领域对象的一些比较紧密依赖持久化逻辑被分离到Service层，显得不够OO。（可以理解为部分执行的业务逻辑放到了API服务去聚合了）</p>
<p>2、Service层过于厚重。</p>
<h3 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a><strong>充血模型</strong></h3><p>充血模型是指数据和对应的业务逻辑被封装到同一个类中，甚至将一些持久化逻辑也封装在类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p>
<p><strong>优点</strong></p>
<p>1、面向对象，业务逻辑符合单一职责，不像在贫血模型里面那样包含所有的业务逻辑太过沉重</p>
<p><strong>缺点</strong></p>
<p>1、缺点是如何划分业务逻辑，什么样的逻辑应该放在领域服务中，什么样的业务逻辑应该放在应用服务中，这是很含糊的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutTaskPO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   字段: id</span></span><br><span class="line"><span class="comment">     *   说明: 自增主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   字段: out_task_id</span></span><br><span class="line"><span class="comment">     *   说明: 全局唯一id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long outTaskId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   字段: poi_id</span></span><br><span class="line"><span class="comment">     *   说明: 网格站id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long poiId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   字段: plan_take_date</span></span><br><span class="line"><span class="comment">     *   说明: 计划自提日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate planTakeDate;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   任务领取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTask</span><span class="params">(Long poiId, String taskNo)</span> </span>&#123;</span><br><span class="line">    			......</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><ul>
<li><p>贫血模型 + Service</p>
<p>  <img src="/blogImg/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B.jpg" alt="贫血模型"></p>
</li>
<li><p>充血模型（领域模型）（再不一定贴切的举个栗子，任务状态变化就需要记录任务流水，所以任务状态变更的这个行为触发了更新任务对象记录流水这个逻辑）</p>
<p>  <img src="/blogImg/%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.jpg" alt="充血模型"></p>
</li>
</ul>
<p>基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。</p>
<p>面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，主要是有下面三点原因。</p>
<p><strong>为什么基于贫血模型的传统开发模式如此受欢迎？</strong></p>
<p>1、大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。</p>
<p>2、充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。</p>
<p>3、思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。</p>
<p><strong>什么项目应该考虑使用基于充血模型的 DDD 开发模式？</strong></p>
<p>基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p>
<p>你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的 DDD 开发模式就可以呢？</p>
<p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到 Service 层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。</p>
<p>不夸张地讲，我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Thrift 类中添加代码。</p>
<p>业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满天飞。</p>
<p>所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。</p>
<p>如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p>
<h3 id="CURS："><a href="#CURS：" class="headerlink" title="CURS："></a><strong>CURS：</strong></h3><p>就是命令查询分离，或者说读写分离模式，写入和查询对应不同的数据模型。 一般实现方案是数据写入之后，发送事件，消费方可根据时间构建自己的读视图数据，读写解耦，可分别进行优化。之前的分级存储，读写分离</p>
<h2 id="对应到分拣的例子："><a href="#对应到分拣的例子：" class="headerlink" title="对应到分拣的例子："></a><strong>对应到分拣的例子：</strong></h2><table>
<thead>
<tr>
<th>领域对象名称（通用语言）</th>
<th>领域类型</th>
</tr>
</thead>
<tbody><tr>
<td>分拣任务</td>
<td>聚合根</td>
</tr>
<tr>
<td>分拣任务明细</td>
<td>实体</td>
</tr>
<tr>
<td><del>分拣任务聚合方式</del></td>
<td><del>实体</del></td>
</tr>
<tr>
<td>商品信息</td>
<td>值对象</td>
</tr>
<tr>
<td>任务标签</td>
<td>值对象</td>
</tr>
<tr>
<td>任务保存</td>
<td>领域事件</td>
</tr>
<tr>
<td>任务领取</td>
<td>领域事件</td>
</tr>
<tr>
<td>退出任务</td>
<td>领域事件</td>
</tr>
<tr>
<td>结束任务</td>
<td>领域事件</td>
</tr>
</tbody></table>
<h2 id="旧工程和DDD"><a href="#旧工程和DDD" class="headerlink" title="旧工程和DDD"></a>旧工程和DDD</h2><p><img src="/blogImg/%E6%97%A7%E5%B7%A5%E7%A8%8B%E5%92%8CDDD.jpg" alt="旧工程和DDD"></p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="/img/jump.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/Wechatpay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/Wechatpay.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/09/RocketMQ%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src="/blogImg/RocketMQ%E7%9A%84%E6%B6%88%E8%B4%B9%E9%80%BB%E8%BE%91.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RocketMQ详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/15/CompletableFuture%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="/blogImg/CompletableFuture%E8%AF%A6%E8%A7%A3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CompletableFuture详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/10/23/设计模式总结——结构型模式/" title="设计模式总结——结构型模式"><img class="cover" src="/blogImg/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">设计模式总结——结构型模式</div></div></a></div><div><a href="/2020/10/23/设计模式总结——行为型模式/" title="设计模式总结——行为型模式"><img class="cover" src="/blogImg/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-23</div><div class="title">设计模式总结——行为型模式</div></div></a></div><div><a href="/2020/09/30/设计模式总结——创建型模式/" title="设计模式总结——创建型模式"><img class="cover" src="/blogImg/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-30</div><div class="title">设计模式总结——创建型模式</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Wangpengyu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'silence314/commit-utterances')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>