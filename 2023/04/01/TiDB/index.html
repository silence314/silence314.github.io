<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TiDB | 王鹏宇的博客</title><meta name="description" content="首先放TiDB的gitbook，里面对于tidb的大部分内容都有详细的介绍：https:&#x2F;&#x2F;book.tidb.io&#x2F; 其次实际的应用当然需要PingCAP的官方文档：https:&#x2F;&#x2F;docs.pingcap.com&#x2F;zh&#x2F;tidb&#x2F;stable&#x2F;overview，因为自己只是想了解下TiDB，感觉这个数据库有点火，大致了解一下工作原理，自己在上一家公司有实际使用接触过，但是因为当时自己经验不足，"><meta name="keywords" content="数据库,TiDB"><meta name="author" content="Wangpengyu"><meta name="copyright" content="Wangpengyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/01/TiDB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="TiDB"><meta property="og:url" content="http://example.com/2023/04/01/TiDB/"><meta property="og:site_name" content="王鹏宇的博客"><meta property="og:description" content="首先放TiDB的gitbook，里面对于tidb的大部分内容都有详细的介绍：https:&#x2F;&#x2F;book.tidb.io&#x2F; 其次实际的应用当然需要PingCAP的官方文档：https:&#x2F;&#x2F;docs.pingcap.com&#x2F;zh&#x2F;tidb&#x2F;stable&#x2F;overview，因为自己只是想了解下TiDB，感觉这个数据库有点火，大致了解一下工作原理，自己在上一家公司有实际使用接触过，但是因为当时自己经验不足，"><meta property="og:image" content="http://example.com/img/jump.png"><meta property="article:published_time" content="2023-04-01T07:03:53.000Z"><meta property="article:modified_time" content="2023-04-08T08:44:23.019Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-04-08 16:44:23'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">96</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">51</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TiDB%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">TiDB简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">五大核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">四大核心应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TiDB%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">TiDB整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Key-Value-Pairs-%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">Key-Value Pairs (键值对)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%88RocksDB%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">本地存储（RocksDB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">Raft 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Region"><span class="toc-number">2.1.4.</span> <span class="toc-text">Region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC"><span class="toc-number">2.1.5.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-ACID-%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.1.6.</span> <span class="toc-text">分布式 ACID 事务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.</span> <span class="toc-text">计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%B8%8E-Key-Value-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">表数据与 Key-Value 的映射关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%B8%8E-Key-Value-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">表数据与 Key-Value 的映射关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E5%92%8C-Key-Value-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.3.</span> <span class="toc-text">索引数据和 Key-Value 的映射关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">映射关系小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Key-Value-%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.5.</span> <span class="toc-text">Key-Value 映射关系示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.6.</span> <span class="toc-text">元信息管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-%E5%B1%82%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.7.</span> <span class="toc-text">SQL 层简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.8.</span> <span class="toc-text">SQL 运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-SQL-%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.9.</span> <span class="toc-text">分布式 SQL 运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.10.</span> <span class="toc-text">SQL 层架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TiDB%E5%92%8CMysql%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">TiDB和Mysql的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E7%AD%96%E7%95%A5"><span class="toc-number">3.1.</span> <span class="toc-text">兼容策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E7%82%B9%E8%AF%A6%E8%BF%B0%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88"><span class="toc-number">3.2.</span> <span class="toc-text">区别点详述及应对方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E6%94%AF%E6%8C%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">字符集支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA"><span class="toc-number">3.2.2.</span> <span class="toc-text">系统时区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">乐观事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.1.1.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">并发控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TiDB-%E4%B9%90%E8%A7%82%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">TiDB 乐观事务实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Snapshot-Isolation"><span class="toc-number">4.2.1.</span> <span class="toc-text">Snapshot Isolation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%882PC%EF%BC%89"><span class="toc-number">4.2.2.</span> <span class="toc-text">两阶段提交（2PC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">两阶段提交过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">悲观事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">悲观锁解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Percolator-%E7%9A%84%E6%82%B2%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.3.2.</span> <span class="toc-text">基于 Percolator 的悲观事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E9%94%81%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">等锁顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">分布式死锁检测</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/jump.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王鹏宇的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">TiDB</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-01T07:03:53.000Z" title="发表于 2023-04-01 15:03:53">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-08T08:44:23.019Z" title="更新于 2023-04-08 16:44:23">2023-04-08</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>首先放TiDB的gitbook，里面对于tidb的大部分内容都有详细的介绍：<a target="_blank" rel="noopener" href="https://book.tidb.io/">https://book.tidb.io/</a></p>
<p>其次实际的应用当然需要PingCAP的官方文档：<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/overview%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8F%AA%E6%98%AF%E6%83%B3%E4%BA%86%E8%A7%A3%E4%B8%8BTiDB%EF%BC%8C%E6%84%9F%E8%A7%89%E8%BF%99%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E7%82%B9%E7%81%AB%EF%BC%8C%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%9C%A8%E4%B8%8A%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E6%9C%89%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E6%8E%A5%E8%A7%A6%E8%BF%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%BD%93%E6%97%B6%E8%87%AA%E5%B7%B1%E7%BB%8F%E9%AA%8C%E4%B8%8D%E8%B6%B3%EF%BC%8C%E4%B8%8D%E8%A7%89%E5%BE%97%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB%E6%88%96%E8%80%85%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%B0%B1%E6%B2%A1%E6%9C%89%E8%BF%87%E5%A4%9A%E4%BA%86%E8%A7%A3%E3%80%82%E7%8E%B0%E5%9C%A8%E5%9C%A8%E7%BE%8E%E5%9B%A2%E5%85%AC%E5%8F%B8%E5%86%85%E9%83%A8%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E8%B4%9F%E8%B4%A3%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%AE%9E%E9%99%85%E7%94%A8%E4%B8%8D%E5%88%B0%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BB%A5Mysql%E4%B8%BA%E4%B8%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E8%BF%99%E9%87%8C%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E8%BF%99%E4%BA%9B%E8%B5%84%E6%96%99%EF%BC%8C%E5%AF%B9TiDB%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%82">https://docs.pingcap.com/zh/tidb/stable/overview，因为自己只是想了解下TiDB，感觉这个数据库有点火，大致了解一下工作原理，自己在上一家公司有实际使用接触过，但是因为当时自己经验不足，不觉得他有什么特别或者不同，就没有过多了解。现在在美团公司内部有自己的分布式数据库，但是我负责的业务场景实际用不到，还是以Mysql为主，所以在这里根据网络上的这些资料，对TiDB做一个简单的学习和总结。</a></p>
<h2 id="TiDB简介"><a href="#TiDB简介" class="headerlink" title="TiDB简介"></a>TiDB简介</h2><p><a target="_blank" rel="noopener" href="https://github.com/pingcap/tidb">TiDB</a> 是 <a target="_blank" rel="noopener" href="https://pingcap.com/about-cn/">PingCAP</a> 公司自主设计、研发的开源分布式关系型数据库，是一款同时支持在线事务处理与在线分析处理 (Hybrid Transactional and Analytical Processing, HTAP) 的融合型分布式数据库产品，具备水平扩容或者缩容、金融级高可用、实时 HTAP、云原生的分布式数据库、兼容 MySQL 5.7 协议和 MySQL 生态等重要特性。目标是为用户提供一站式 OLTP (Online Transactional Processing)、OLAP (Online Analytical Processing)、HTAP 解决方案。TiDB 适合高可用、强一致要求较高、数据规模较大等各种应用场景。</p>
<h3 id="五大核心特性"><a href="#五大核心特性" class="headerlink" title="五大核心特性"></a>五大核心特性</h3><ul>
<li><p>一键水平扩容或者缩容</p>
<p>  得益于 TiDB 存储计算分离的架构的设计，可按需对计算、存储分别进行在线扩容或者缩容，扩容或者缩容过程中对应用运维人员透明。</p>
</li>
<li><p>金融级高可用</p>
<p>  数据采用多副本存储，数据副本通过 Multi-Raft 协议同步事务日志，多数派写入成功事务才能提交，确保数据强一致性且少数副本发生故障时不影响数据的可用性。可按需配置副本地理位置、副本数量等策略满足不同容灾级别的要求。</p>
</li>
<li><p>实时 HTAP</p>
<p>  提供行存储引擎 <a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/tikv-overview">TiKV</a>、列存储引擎 <a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/tiflash-overview">TiFlash</a> 两款存储引擎，TiFlash 通过 Multi-Raft Learner 协议实时从 TiKV 复制数据，确保行存储引擎 TiKV 和列存储引擎 TiFlash 之间的数据强一致。TiKV、TiFlash 可按需部署在不同的机器，解决 HTAP 资源隔离的问题。</p>
</li>
<li><p>云原生的分布式数据库</p>
<p>  专为云而设计的分布式数据库，通过 <a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb-in-kubernetes/stable/tidb-operator-overview">TiDB Operator</a> 可在公有云、私有云、混合云中实现部署工具化、自动化。</p>
</li>
<li><p>兼容 MySQL 5.7 协议和 MySQL 生态</p>
<p>  兼容 MySQL 5.7 协议、MySQL 常用的功能、MySQL 生态，应用无需或者修改少量代码即可从 MySQL 迁移到 TiDB。提供丰富的<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/ecosystem-tool-user-guide">数据迁移工具</a>帮助应用便捷完成数据迁移。</p>
</li>
</ul>
<h3 id="四大核心应用场景"><a href="#四大核心应用场景" class="headerlink" title="四大核心应用场景"></a>四大核心应用场景</h3><ul>
<li><p>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景</p>
<p>  众所周知，金融行业对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高。传统的解决方案是同城两个机房提供服务、异地一个机房提供数据容灾能力但不提供服务，此解决方案存在以下缺点：资源利用率低、维护成本高、RTO (Recovery Time Objective) 及 RPO (Recovery Point Objective) 无法真实达到企业所期望的值。TiDB 采用多副本 + Multi-Raft 协议的方式将数据调度到不同的机房、机架、机器，当部分机器出现故障时系统可自动进行切换，确保系统的 RTO &lt;= 30s 及 RPO = 0。</p>
</li>
<li><p>对存储容量、可扩展性、并发要求较高的海量数据及高并发的 OLTP 场景</p>
<p>  随着业务的高速发展，数据呈现爆炸性的增长，传统的单机数据库无法满足因数据爆炸性的增长对数据库的容量要求，可行方案是采用分库分表的中间件产品或者 NewSQL 数据库替代、采用高端的存储设备等，其中性价比最大的是 NewSQL 数据库，例如：TiDB。TiDB 采用计算、存储分离的架构，可对计算、存储分别进行扩容和缩容，计算最大支持 512 节点，每个节点最大支持 1000 并发，集群容量最大支持 PB 级别。</p>
</li>
<li><p>Real-time HTAP 场景</p>
<p>  随着 5G、物联网、人工智能的高速发展，企业所生产的数据会越来越多，其规模可能达到数百 TB 甚至 PB 级别，传统的解决方案是通过 OLTP 型数据库处理在线联机交易业务，通过 ETL 工具将数据同步到 OLAP 型数据库进行数据分析，这种处理方案存在存储成本高、实时性差等多方面的问题。TiDB 在 4.0 版本中引入列存储引擎 TiFlash 结合行存储引擎 TiKV 构建真正的 HTAP 数据库，在增加少量存储成本的情况下，可以在同一个系统中做联机交易处理、实时数据分析，极大地节省企业的成本。</p>
</li>
<li><p>数据汇聚、二次加工处理的场景</p>
<p>  当前绝大部分企业的业务数据都分散在不同的系统中，没有一个统一的汇总，随着业务的发展，企业的决策层需要了解整个公司的业务状况以便及时做出决策，故需要将分散在各个系统的数据汇聚在同一个系统并进行二次加工处理生成 T+0 或 T+1 的报表。传统常见的解决方案是采用 ETL + Hadoop 来完成，但 Hadoop 体系太复杂，运维、存储成本太高无法满足用户的需求。与 Hadoop 相比，TiDB 就简单得多，业务通过 ETL 工具或者 TiDB 的同步工具将数据同步到 TiDB，在 TiDB 中可通过 SQL 直接生成报表。</p>
</li>
</ul>
<h2 id="TiDB整体架构"><a href="#TiDB整体架构" class="headerlink" title="TiDB整体架构"></a>TiDB整体架构</h2><p>在内核设计上，TiDB 分布式数据库将整体架构拆分成了多个模块，各模块之间互相通信，组成完整的 TiDB 系统。对应的架构图如下：</p>
<p><img src="https://download.pingcap.com/images/docs-cn/tidb-architecture-v6.png" alt="architecture"></p>
<ul>
<li>TiDB Server：SQL 层，对外暴露 MySQL 协议的连接 endpoint，负责接受客户端的连接，执行 SQL 解析和优化，最终生成分布式执行计划。TiDB 层本身是无状态的，实践中可以启动多个 TiDB 实例，通过负载均衡组件（如 LVS、HAProxy 或 F5）对外提供统一的接入地址，客户端的连接可以均匀地分摊在多个 TiDB 实例上以达到负载均衡的效果。TiDB Server 本身并不存储数据，只是解析 SQL，将实际的数据读取请求转发给底层的存储节点 TiKV（或 TiFlash）。</li>
<li>PD (Placement Driver) Server：整个 TiDB 集群的元信息管理模块，负责存储每个 TiKV 节点实时的数据分布情况和集群的整体拓扑结构，提供 TiDB Dashboard 管控界面，并为分布式事务分配事务 ID。PD 不仅存储元信息，同时还会根据 TiKV 节点实时上报的数据分布状态，下发数据调度命令给具体的 TiKV 节点，可以说是整个集群的“大脑”。此外，PD 本身也是由至少 3 个节点构成，拥有高可用的能力。建议部署奇数个 PD 节点。</li>
<li>存储节点<ul>
<li>TiKV Server：负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region，每个 Region 负责存储一个 Key Range（从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region。TiKV 的 API 在 KV 键值对层面提供对分布式事务的原生支持，默认提供了 SI (Snapshot Isolation) 的隔离级别，这也是 TiDB 在 SQL 层面支持分布式事务的核心。TiDB 的 SQL 层做完 SQL 解析后，会将 SQL 的执行计划转换为对 TiKV API 的实际调用。所以，数据都存储在 TiKV 中。另外，TiKV 中的数据都会自动维护多副本（默认为三副本），天然支持高可用和自动故障转移。</li>
<li>TiFlash：TiFlash 是一类特殊的存储节点。和普通 TiKV 节点不一样的是，在 TiFlash 内部，数据是以列式的形式进行存储，主要的功能是为分析型的场景加速。</li>
</ul>
</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="Key-Value-Pairs-键值对"><a href="#Key-Value-Pairs-键值对" class="headerlink" title="Key-Value Pairs (键值对)"></a>Key-Value Pairs (键值对)</h4><p>作为保存数据的系统，首先要决定的是数据的存储模型，也就是数据以什么样的形式保存下来。TiKV 的选择是 Key-Value 模型，并且提供有序遍历方法。 TiKV 数据存储的两个关键点：</p>
<ol>
<li>这是一个巨大的 Map（可以类比一下 C++ 的 std::map），也就是存储的是 Key-Value Pairs（键值对）</li>
<li>这个 Map 中的 Key-Value pair 按照 Key 的二进制顺序有序，也就是可以 Seek 到某一个 Key 的位置，然后不断地调用 Next 方法以递增的顺序获取比这个 Key 大的 Key-Value。</li>
</ol>
<p>有人可能会问，这里讲的存储模型和 SQL 中表是什么关系？在这里有一件重要的事情需要强调：</p>
<p><strong>TiKV 的 KV 存储模型和 SQL 中的 Table 无关！</strong></p>
<p>现在让我们忘记 SQL 中的任何概念，专注于讨论如何实现 TiKV 这样一个高性能、高可靠性、分布式的 Key-Value 存储。</p>
<h4 id="本地存储（RocksDB）"><a href="#本地存储（RocksDB）" class="headerlink" title="本地存储（RocksDB）"></a>本地存储（RocksDB）</h4><p>任何持久化的存储引擎，数据终归要保存在磁盘上，TiKV 也不例外。但是 TiKV 没有选择直接向磁盘上写数据，而是把数据保存在 RocksDB 中，具体的数据落地由 RocksDB 负责。这个选择的原因是开发一个单机存储引擎工作量很大，特别是要做一个高性能的单机引擎，需要做各种细致的优化，而 RocksDB 是由 Facebook 开源的一个非常优秀的单机 KV 存储引擎，可以满足 TiKV 对单机引擎的各种要求。这里可以简单的认为 RocksDB 是一个单机的持久化 Key-Value Map。</p>
<h4 id="Raft-协议"><a href="#Raft-协议" class="headerlink" title="Raft 协议"></a>Raft 协议</h4><p>接下来 TiKV 的实现面临一件更难的事情：如何保证单机失效的情况下，数据不丢失，不出错？</p>
<p>简单来说，需要想办法把数据复制到多台机器上，这样一台机器挂了，其他的机器上的副本还能提供服务； 复杂来说，还需要这个数据复制方案是可靠和高效的，并且能处理副本失效的情况。TiKV 选择了 Raft 算法。Raft 是一个一致性协议，它和 Multi Paxos 实现一样的功能，但是更加易于理解。<a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">这里</a> 是 Raft 的论文，感兴趣的可以看一下。下面对 Raft 做一个简要的介绍，细节问题可以参考论文。 Raft 提供几个重要的功能：</p>
<ol>
<li>Leader（主副本）选举</li>
<li>成员变更（如添加副本、删除副本、转移 Leader 等操作）</li>
<li>日志复制</li>
</ol>
<p>TiKV 利用 Raft 来做数据复制，每个数据变更都会落地为一条 Raft 日志，通过 Raft 的日志复制功能，将数据安全可靠地同步到复制组的每一个节点中。不过在实际写入中，根据 Raft 的协议，只需要同步复制到多数节点，即可安全地认为数据写入成功。</p>
<p><img src="https://book.tidb.io/res/session1/chapter2/tidb-storage/1.png" alt="1.png"></p>
<p>总结一下，通过单机的 RocksDB，TiKV 可以将数据快速地存储在磁盘上；通过 Raft，将数据复制到多台机器上，以防单机失效。数据的写入是通过 Raft 这一层的接口写入，而不是直接写 RocksDB。通过实现 Raft，TiKV 变成了一个分布式的 Key-Value 存储，少数几台机器宕机也能通过原生的 Raft 协议自动把副本补全，可以做到对业务无感知。</p>
<h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>讲到这里，我们需要提到一个非常重要的概念：Region。这个概念是理解后续一系列机制的基础，请仔细阅读这一小节。 前面提到，我们将 TiKV 看做一个巨大的有序的 KV Map，那么为了实现存储的水平扩展，我们需要将数据分散在多台机器上。这里提到的数据分散在多台机器上和 Raft 的数据复制不是一个概念，在这一节我们先忘记 Raft，假设所有的数据都只有一个副本，这样更容易理解。 对于一个 KV 系统，将数据分散在多台机器上有两种比较典型的方案：</p>
<ul>
<li>Hash：按照 Key 做 Hash，根据 Hash 值选择对应的存储节点</li>
<li>Range：按照 Key 分 Range，某一段连续的 Key 都保存在一个存储节点上</li>
</ul>
<p>TiKV 选择了第二种方式，将整个 Key-Value 空间分成很多段，每一段是一系列连续的 Key，将每一段叫做一个 Region，并且会尽量保持每个 Region 中保存的数据不超过一定的大小，目前在 TiKV 中默认是 96MB。每一个 Region 都可以用 [StartKey，EndKey) 这样一个左闭右开区间来描述。</p>
<p><img src="https://book.tidb.io/res/session1/chapter2/tidb-storage/2.png" alt="2.png"></p>
<p>注意，这里的 Region 还是和 SQL 中的表没什么关系！ 请各位继续忘记 SQL，只谈 KV。 将数据划分成 Region 后，TiKV 将会做两件重要的事情：</p>
<ul>
<li>以 Region 为单位，将数据分散在集群中所有的节点上，并且尽量保证每个节点上服务的 Region 数量差不多</li>
<li>以 Region 为单位做 Raft 的复制和成员管理</li>
</ul>
<p>这两点非常重要，我们一点一点来说。 先看第一点，数据按照 Key 切分成很多 Region，每个 Region 的数据只会保存在一个节点上面（暂不考虑多副本）。TiDB 系统会有一个组件（PD）来负责将 Region 尽可能均匀的散布在集群中所有的节点上，这样一方面实现了存储容量的水平扩展（增加新的节点后，会自动将其他节点上的 Region 调度过来），另一方面也实现了负载均衡（不会出现某个节点有很多数据，其他节点上没什么数据的情况）。同时为了保证上层客户端能够访问所需要的数据，系统中也会有一个组件（PD）记录 Region 在节点上面的分布情况，也就是通过任意一个 Key 就能查询到这个 Key 在哪个 Region 中，以及这个 Region 目前在哪个节点上（即 Key 的位置路由信息）。至于负责这两项重要工作的组件（PD），会在后续介绍。</p>
<p>对于第二点，TiKV 是以 Region 为单位做数据的复制，也就是一个 Region 的数据会保存多个副本，TiKV 将每一个副本叫做一个 Replica。Replica 之间是通过 Raft 来保持数据的一致，一个 Region 的多个 Replica 会保存在不同的节点上，构成一个 Raft Group。其中一个 Replica 会作为这个 Group 的 Leader，其他的 Replica 作为 Follower。所有的读和写都是通过 Leader 进行，读操作在 Leader 上即可完成，而写操作再由 Leader 复制给 Follower。 大家理解了 Region 之后，应该可以理解下面这张图：</p>
<p><img src="https://book.tidb.io/res/session1/chapter2/tidb-storage/3.png" alt="3.png"></p>
<p>以 Region 为单位做数据的分散和复制，就有了一个分布式的具备一定容灾能力的 KeyValue 系统，不用再担心数据存不下，或者是磁盘故障丢失数据的问题。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>很多数据库都会实现多版本并发控制（MVCC），TiKV 也不例外。设想这样的场景，两个客户端同时去修改一个 Key 的 Value，如果没有数据的多版本控制，就需要对数据上锁，在分布式场景下，可能会带来性能以及死锁问题。 TiKV 的 MVCC 实现是通过在 Key 后面添加版本号来实现，简单来说，没有 MVCC 之前，可以把 TiKV 看做这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Key1 -&gt; Value</span><br><span class="line">Key2 -&gt; Value</span><br><span class="line">……</span><br><span class="line">KeyN -&gt; Value</span><br></pre></td></tr></table></figure>

<p>有了 MVCC 之后，TiKV 的 Key 排列是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Key1_Version3 -&gt; Value</span><br><span class="line">Key1_Version2 -&gt; Value</span><br><span class="line">Key1_Version1 -&gt; Value</span><br><span class="line">……</span><br><span class="line">Key2_Version4 -&gt; Value</span><br><span class="line">Key2_Version3 -&gt; Value</span><br><span class="line">Key2_Version2 -&gt; Value</span><br><span class="line">Key2_Version1 -&gt; Value</span><br><span class="line">……</span><br><span class="line">KeyN_Version2 -&gt; Value</span><br><span class="line">KeyN_Version1 -&gt; Value</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>注意，对于同一个 Key 的多个版本，我们把版本号较大的放在前面，版本号小的放在后面（回忆一下 Key-Value 一节我们介绍过的 Key 是有序的排列），这样当用户通过一个 Key + Version 来获取 Value 的时候，可以通过 Key 和 Version 构造出 MVCC 的 Key，也就是 Key_Version。然后可以直接通过 RocksDB 的 SeekPrefix(Key_Version) API，定位到第一个大于等于这个 Key_Version 的位置。</p>
<h4 id="分布式-ACID-事务"><a href="#分布式-ACID-事务" class="headerlink" title="分布式 ACID 事务"></a>分布式 ACID 事务</h4><p>TiKV 的事务采用的是 Google 在 BigTable 中使用的事务模型：<a target="_blank" rel="noopener" href="https://research.google.com/pubs/pub36726.html">Percolator</a>，TiKV 根据这篇论文实现，并做了大量的优化。这个在后续的章节中会有详细的介绍。</p>
<p>在 TiKV 层的事务 API 的语义类似下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tx &#x3D; tikv.Begin()</span><br><span class="line">    tx.Set(Key1, Value1)</span><br><span class="line">    tx.Set(Key2, Value2)</span><br><span class="line">    tx.Set(Key3, Value3)</span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure>

<p>这个事务中包含3条 Set 操作，TiKV 能保证这些操作要么全部成功，要么全部失败，不会出现中间状态或脏数据。 就如前面提到的，TiDB 的 SQL 层会将 SQL 的执行计划转换成多个 KV 操作，对于上层的同一个业务层的 SQL 事务，在底层也是对应一个 KV 层的事务，这是 TiDB 实现 MySQL 的事务语义的关键。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><h4 id="表数据与-Key-Value-的映射关系"><a href="#表数据与-Key-Value-的映射关系" class="headerlink" title="表数据与 Key-Value 的映射关系"></a>表数据与 Key-Value 的映射关系</h4><p>本小节介绍 TiDB 中数据到 (Key, Value) 键值对的映射方案。这里的数据主要包括以下两个方面：</p>
<ul>
<li>表中每一行的数据，以下简称表数据</li>
<li>表中所有索引的数据，以下简称索引数据</li>
</ul>
<h4 id="表数据与-Key-Value-的映射关系-1"><a href="#表数据与-Key-Value-的映射关系-1" class="headerlink" title="表数据与 Key-Value 的映射关系"></a>表数据与 Key-Value 的映射关系</h4><p>在关系型数据库中，一个表可能有很多列。要将一行中各列数据映射成一个 (Key, Value) 键值对，需要考虑如何构造 Key。首先，OLTP 场景下有大量针对单行或者多行的增、删、改、查等操作，要求数据库具备快速读取一行数据的能力。因此，对应的 Key 最好有一个唯一 ID（显示或隐式的 ID），以方便快速定位。其次，很多 OLAP 型查询需要进行全表扫描。如果能够将一个表中所有行的 Key 编码到一个区间内，就可以通过范围查询高效完成全表扫描的任务。</p>
<p>基于上述考虑，TiDB 中的表数据与 Key-Value 的映射关系作了如下设计：</p>
<ul>
<li>为了保证同一个表的数据放在一起，方便查找，TiDB 会为每个表分配一个表 ID，用 <code>TableID</code> 表示。表 ID 是一个整数，在整个集群内唯一。</li>
<li>TiDB 会为表中每行数据分配一个行 ID，用 <code>RowID</code> 表示。行 ID 也是一个整数，在表内唯一。对于行 ID，TiDB 做了一个小优化，如果某个表有整数型的主键，TiDB 会使用主键的值当做这一行数据的行 ID。</li>
</ul>
<p>每行数据按照如下规则编码成 (Key, Value) 键值对：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Key:</span>   tablePrefix&#123;TableID&#125;_recordPrefixSep&#123;RowID&#125;</span><br><span class="line"><span class="symbol">Value:</span> [col1, col2, col3, col4]</span><br></pre></td></tr></table></figure>

<p>其中 <code>tablePrefix</code> 和 <code>recordPrefixSep</code> 都是特定的字符串常量，用于在 Key 空间内区分其他数据。其具体值在后面的小结中给出。</p>
<h4 id="索引数据和-Key-Value-的映射关系"><a href="#索引数据和-Key-Value-的映射关系" class="headerlink" title="索引数据和 Key-Value 的映射关系"></a>索引数据和 Key-Value 的映射关系</h4><p>TiDB 同时支持主键和二级索引（包括唯一索引和非唯一索引）。与表数据映射方案类似，TiDB 为表中每个索引分配了一个索引 ID，用 <code>IndexID</code> 表示。</p>
<p>对于主键和唯一索引，需要根据键值快速定位到对应的 RowID，因此，按照如下规则编码成 (Key, Value) 键值对：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key:   tablePrefix&#123;tableID&#125;<span class="emphasis">_indexPrefixSep&#123;indexID&#125;_</span>indexedColumnsValue</span><br><span class="line">Value: RowID</span><br></pre></td></tr></table></figure>

<p>对于不需要满足唯一性约束的普通二级索引，一个键值可能对应多行，需要根据键值范围查询对应的 RowID。因此，按照如下规则编码成 (Key, Value) 键值对：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">Key:   tablePrefix</span><span class="template-variable">&#123;TableID&#125;</span><span class="xml">_indexPrefixSep</span><span class="template-variable">&#123;IndexID&#125;</span><span class="xml">_indexedColumnsValue_</span><span class="template-variable">&#123;RowID&#125;</span></span><br><span class="line"><span class="xml">Value: null</span></span><br></pre></td></tr></table></figure>

<h4 id="映射关系小结"><a href="#映射关系小结" class="headerlink" title="映射关系小结"></a>映射关系小结</h4><p>上述所有编码规则中的 <code>tablePrefix</code>、<code>recordPrefixSep</code> 和 <code>indexPrefixSep</code> 都是字符串常量，用于在 Key 空间内区分其他数据，定义如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tablePrefix</span>     = []byte&#123;<span class="string">&#x27;t&#x27;</span>&#125;</span><br><span class="line"><span class="attr">recordPrefixSep</span> = []byte&#123;<span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"><span class="attr">indexPrefixSep</span>  = []byte&#123;<span class="string">&#x27;i&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另外请注意，上述方案中，无论是表数据还是索引数据的 Key 编码方案，一个表内所有的行都有相同的 Key 前缀，一个索引的所有数据也都有相同的前缀。这样具有相同的前缀的数据，在 TiKV 的 Key 空间内，是排列在一起的。因此只要小心地设计后缀部分的编码方案，保证编码前和编码后的比较关系不变，就可以将表数据或者索引数据有序地保存在 TiKV 中。采用这种编码后，一个表的所有行数据会按照 <code>RowID</code> 顺序地排列在 TiKV 的 Key 空间中，某一个索引的数据也会按照索引数据的具体的值（编码方案中的 <code>indexedColumnsValue</code>）顺序地排列在 Key 空间内。</p>
<h4 id="Key-Value-映射关系示例"><a href="#Key-Value-映射关系示例" class="headerlink" title="Key-Value 映射关系示例"></a>Key-Value 映射关系示例</h4><p>最后通过一个简单的例子，来理解 TiDB 的 Key-Value 映射关系。假设 TiDB 中有如下这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">User</span> (</span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">Role</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    Age <span class="built_in">int</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">ID</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idxAge (Age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>假设该表中有 3 行数据：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>, <span class="string">&quot;TiDB&quot;</span>, <span class="string">&quot;SQL Layer&quot;</span>, <span class="number">10</span></span><br><span class="line"><span class="attribute">2</span>, <span class="string">&quot;TiKV&quot;</span>, <span class="string">&quot;KV Engine&quot;</span>, <span class="number">20</span></span><br><span class="line"><span class="attribute">3</span>, <span class="string">&quot;PD&quot;</span>, <span class="string">&quot;Manager&quot;</span>, <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>首先每行数据都会映射为一个 (Key, Value) 键值对，同时该表有一个 <code>int</code> 类型的主键，所以 <code>RowID</code> 的值即为该主键的值。假设该表的 <code>TableID</code> 为 10，则其存储在 TiKV 上的表数据为：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">t10_r1</span> --&gt;</span> [<span class="string">&quot;TiDB&quot;</span>, <span class="string">&quot;SQL Layer&quot;</span>, <span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="title">t10_r2</span> --&gt;</span> [<span class="string">&quot;TiKV&quot;</span>, <span class="string">&quot;KV Engine&quot;</span>, <span class="number">20</span>]</span><br><span class="line"><span class="function"><span class="title">t10_r3</span> --&gt;</span> [<span class="string">&quot;PD&quot;</span>, <span class="string">&quot;Manager&quot;</span>, <span class="number">30</span>]</span><br></pre></td></tr></table></figure>

<p>除了主键外，该表还有一个非唯一的普通二级索引 <code>idxAge</code>，假设这个索引的 <code>IndexID</code> 为 1，则其存储在 TiKV 上的索引数据为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t10_i1_10_1<span class="function"> --&gt;</span> <span class="literal">null</span></span><br><span class="line">t10_i1_20_2<span class="function"> --&gt;</span> <span class="literal">null</span></span><br><span class="line">t10_i1_30_3<span class="function"> --&gt;</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>以上例子展示了 TiDB 中关系模型到 Key-Value 模型的映射规则，以及选择该方案背后的考量。</p>
<h4 id="元信息管理"><a href="#元信息管理" class="headerlink" title="元信息管理"></a>元信息管理</h4><p>TiDB 中每个 <code>Database</code> 和 <code>Table</code> 都有元信息，也就是其定义以及各项属性。这些信息也需要持久化，TiDB 将这些信息也存储在了 TiKV 中。</p>
<p>每个 <code>Database</code>/<code>Table</code> 都被分配了一个唯一的 ID，这个 ID 作为唯一标识，并且在编码为 Key-Value 时，这个 ID 都会编码到 Key 中，再加上 <code>m_</code> 前缀。这样可以构造出一个 Key，Value 中存储的是序列化后的元信息。</p>
<p>除此之外，TiDB 还用一个专门的 (Key, Value) 键值对存储当前所有表结构信息的最新版本号。这个键值对是全局的，每次 DDL 操作的状态改变时其版本号都会加 1。目前，TiDB 把这个键值对持久化存储在 PD Server 中，其 Key 是 “/tidb/ddl/global_schema_version”，Value 是类型为 int64 的版本号值。TiDB 采用 Online Schema 变更算法，有一个后台线程在不断地检查 PD Server 中存储的表结构信息的版本号是否发生变化，并且保证在一定时间内一定能够获取版本的变化。</p>
<h4 id="SQL-层简介"><a href="#SQL-层简介" class="headerlink" title="SQL 层简介"></a>SQL 层简介</h4><p>TiDB 的 SQL 层，即 TiDB Server，负责将 SQL 翻译成 Key-Value 操作，将其转发给共用的分布式 Key-Value 存储层 TiKV，然后组装 TiKV 返回的结果，最终将查询结果返回给客户端。</p>
<p>这一层的节点都是无状态的，节点本身并不存储数据，节点之间完全对等。</p>
<h4 id="SQL-运算"><a href="#SQL-运算" class="headerlink" title="SQL 运算"></a>SQL 运算</h4><p>最简单的方案就是通过上一节所述的<a target="_blank" rel="noopener" href="https://docs.pingcap.com/zh/tidb/stable/tidb-computing#%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%B8%8E-key-value-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB">表数据与 Key-Value 的映射关系</a>方案，将 SQL 查询映射为对 KV 的查询，再通过 KV 接口获取对应的数据，最后执行各种计算。</p>
<p>比如 <code>select count(*) from user where name = &quot;TiDB&quot;</code> 这样一个 SQL 语句，它需要读取表中所有的数据，然后检查 <code>name</code> 字段是否是 <code>TiDB</code>，如果是的话，则返回这一行。具体流程如下：</p>
<ol>
<li>构造出 Key Range：一个表中所有的 <code>RowID</code> 都在 <code>[0, MaxInt64)</code> 这个范围内，使用 <code>0</code> 和 <code>MaxInt64</code> 根据行数据的 <code>Key</code> 编码规则，就能构造出一个 <code>[StartKey, EndKey)</code>的左闭右开区间。</li>
<li>扫描 Key Range：根据上面构造出的 Key Range，读取 TiKV 中的数据。</li>
<li>过滤数据：对于读到的每一行数据，计算 <code>name = &quot;TiDB&quot;</code> 这个表达式，如果为真，则向上返回这一行，否则丢弃这一行数据。</li>
<li>计算 <code>Count(*)</code>：对符合要求的每一行，累计到 <code>Count(*)</code> 的结果上面。</li>
</ol>
<p><strong>整个流程示意图如下：</strong></p>
<p><img src="https://download.pingcap.com/images/docs-cn/tidb-computing-native-sql-flow.jpeg" alt="naive sql flow"></p>
<p>这个方案是直观且可行的，但是在分布式数据库的场景下有一些显而易见的问题：</p>
<ul>
<li>在扫描数据的时候，每一行都要通过 KV 操作从 TiKV 中读取出来，至少有一次 RPC 开销，如果需要扫描的数据很多，那么这个开销会非常大。</li>
<li>并不是所有的行都满足过滤条件 <code>name = &quot;TiDB&quot;</code>，如果不满足条件，其实可以不读取出来。</li>
<li>此查询只要求返回符合要求行的数量，不要求返回这些行的值。</li>
</ul>
<h4 id="分布式-SQL-运算"><a href="#分布式-SQL-运算" class="headerlink" title="分布式 SQL 运算"></a>分布式 SQL 运算</h4><p>为了解决上述问题，计算应该需要尽量靠近存储节点，以避免大量的 RPC 调用。首先，SQL 中的谓词条件 <code>name = &quot;TiDB&quot;</code> 应被下推到存储节点进行计算，这样只需要返回有效的行，避免无意义的网络传输。然后，聚合函数 <code>Count(*)</code> 也可以被下推到存储节点，进行预聚合，每个节点只需要返回一个 <code>Count(*)</code> 的结果即可，再由 SQL 层将各个节点返回的 <code>Count(*)</code> 的结果累加求和。</p>
<p>以下是数据逐层返回的示意图：</p>
<p><img src="https://download.pingcap.com/images/docs-cn/tidb-computing-dist-sql-flow.png" alt="dist sql flow"></p>
<h4 id="SQL-层架构"><a href="#SQL-层架构" class="headerlink" title="SQL 层架构"></a>SQL 层架构</h4><p>通过上面的例子，希望大家对 SQL 语句的处理有一个基本的了解。实际上 TiDB 的 SQL 层要复杂得多，模块以及层次非常多，下图列出了重要的模块以及调用关系：</p>
<p><img src="https://download.pingcap.com/images/docs-cn/tidb-computing-tidb-sql-layer.png" alt="tidb sql layer"></p>
<p>用户的 SQL 请求会直接或者通过 <code>Load Balancer</code> 发送到 TiDB Server，TiDB Server 会解析 <code>MySQL Protocol Packet</code>，获取请求内容，对 SQL 进行语法解析和语义分析，制定和优化查询计划，执行查询计划并获取和处理数据。数据全部存储在 TiKV 集群中，所以在这个过程中 TiDB Server 需要和 TiKV 交互，获取数据。最后 TiDB Server 需要将查询结果返回给用户。</p>
<h2 id="TiDB和Mysql的区别"><a href="#TiDB和Mysql的区别" class="headerlink" title="TiDB和Mysql的区别"></a>TiDB和Mysql的区别</h2><p>TiDB 作为开源 NewSQL 数据库的典型代表之一，同样支持 SQL，支持事务 ACID 特性。在通讯协议上，TiDB 选择与 MySQL 完全兼容，并尽可能兼容 MySQL 的语法。因此，基于 MySQL 数据库开发的系统，大多数可以平滑迁移至 TiDB，而几乎不用修改代码。对用户来说，迁移成本极低，过渡自然。</p>
<p>然而，仍有一些 MySQL 的特性和行为，TiDB 目前暂时不支持或表现与 MySQL 有差异。除此之外，TiDB 提供了一些扩展语法和功能，为用户提供更多的便利。</p>
<p>TiDB 仍处在快速发展的道路上，对 MySQL 功能和行为的支持方面，正按 <a target="_blank" rel="noopener" href="https://pingcap.com/docs-cn/stable/roadmap/">路线图</a> 的规划在前行。</p>
<h3 id="兼容策略"><a href="#兼容策略" class="headerlink" title="兼容策略"></a>兼容策略</h3><p>先从总体上概括 TiDB 和 MySQL 兼容策略，如下表：</p>
<table>
<thead>
<tr>
<th align="left">通讯协议</th>
<th align="left">SQL语法</th>
<th align="left">功能和行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">完全兼容</td>
<td align="left">兼容绝大多数</td>
<td align="left">兼容大多数</td>
</tr>
</tbody></table>
<p>截至 4.0 版本，TiDB 与 MySQL 的区别总结如下表：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">MySQL</th>
<th align="left">TiDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">隔离级别</td>
<td align="left">支持读未提交、读已提交、可重复读、串行化，默认为可重复读</td>
<td align="left">乐观事务支持快照隔离，悲观事务支持快照隔离和读已提交</td>
</tr>
<tr>
<td align="left">锁机制</td>
<td align="left">悲观锁</td>
<td align="left">乐观锁、悲观锁</td>
</tr>
<tr>
<td align="left">存储过程</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">触发器</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">事件</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">自定义函数</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">窗口函数</td>
<td align="left">支持</td>
<td align="left">部分支持</td>
</tr>
<tr>
<td align="left">JSON</td>
<td align="left">支持</td>
<td align="left">不支持部分 MySQL 8.0 新增的函数</td>
</tr>
<tr>
<td align="left">外键约束</td>
<td align="left">支持</td>
<td align="left">忽略外键约束</td>
</tr>
<tr>
<td align="left">字符集</td>
<td align="left"></td>
<td align="left">只支持 ascii、latin1、binary、utf8、utf8mb4</td>
</tr>
<tr>
<td align="left">增加/删除主键</td>
<td align="left">支持</td>
<td align="left">通过 <a target="_blank" rel="noopener" href="https://pingcap.com/docs-cn/dev/reference/configuration/tidb-server/configuration-file/#alter-primary-key">alter-primary-key</a> 配置开关提供</td>
</tr>
<tr>
<td align="left">CREATE TABLE tblName AS SELECT stmt</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">CREATE TEMPORARY TABLE</td>
<td align="left">支持</td>
<td align="left">TiDB 忽略 TEMPORARY 关键字，按照普通表创建</td>
</tr>
<tr>
<td align="left">DML affected rows</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">AutoRandom 列属性</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">Sequence 序列生成器</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
</tbody></table>
<h3 id="区别点详述及应对方案"><a href="#区别点详述及应对方案" class="headerlink" title="区别点详述及应对方案"></a>区别点详述及应对方案</h3><h4 id="字符集支持"><a href="#字符集支持" class="headerlink" title="字符集支持"></a>字符集支持</h4><p>TiDB 目前支持以下字符集：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tidb&gt; SHOW CHARACTER SET;</span><br><span class="line">+<span class="comment">---------|---------------|-------------------|--------+</span></span><br><span class="line">| Charset | Description   | Default collation | Maxlen |</span><br><span class="line">+<span class="comment">---------|---------------|-------------------|--------+</span></span><br><span class="line">| utf8    | UTF-8 Unicode | utf8_bin          |      3 |</span><br><span class="line">| utf8mb4 | UTF-8 Unicode | utf8mb4_bin       |      4 |</span><br><span class="line">| ascii   | US ASCII      | ascii_bin         |      1 |</span><br><span class="line">| latin1  | Latin1        | latin1_bin        |      1 |</span><br><span class="line">| binary  | binary        | binary            |      1 |</span><br><span class="line">+<span class="comment">---------|---------------|-------------------|--------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>注意：TiDB 的默认字符集为 <code>utf8mb4</code>，MySQL 5.7 中为 <code>latin1</code>，MySQL 8.0 中修改为 <code>utf8mb4</code>。 当指定的字符集为 <code>utf8</code> 或 <code>utf8mb4</code> 时，TiDB 仅支持合法的 UTF8 字符。对于不合法的字符，会报错：<code>incorrect utf8 value</code>，该字符合法性检查与 MySQL 8.0 一致。对于 MySQL 5.7 及以下版本，会存在允许插入非法 UTF8 字符，但同步到 TiDB 报错的情况。此时，可以通过 TiDB 配置 <a target="_blank" rel="noopener" href="https://pingcap.com/docs/stable/faq/upgrade/#issue-3-error-1366-hy000-incorrect-utf8-value-f09f8c80-for-column-a">“tidb_skip_utf8_check”</a> 跳过 UTF8 字符合法性检查强制写入 TiDB。</p>
<p>每一个字符集，都有一个默认的 Collation，例如 <code>utf8</code> 的默认 Collation 为 <code>utf8_bin</code>，TiDB 中字符集的默认 Collation 与 MySQL 不一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">字符集</th>
<th align="left">TiDB 默认 Collation</th>
<th align="left">MySQL 5.7 默认 Collation</th>
<th align="left">MySQL 8.0 默认 Collation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">utf8</td>
<td align="left">utf8_bin</td>
<td align="left">utf8_general_ci</td>
<td align="left">utf8_general_ci</td>
</tr>
<tr>
<td align="left">utf8mb4</td>
<td align="left">utf8mb4_bin</td>
<td align="left">utf8mb4_general_ci</td>
<td align="left">utf8mb4_0900_ai_ci</td>
</tr>
<tr>
<td align="left">ascii</td>
<td align="left">ascii_bin</td>
<td align="left">ascii_general_ci</td>
<td align="left">ascii_general_ci</td>
</tr>
<tr>
<td align="left">latin1</td>
<td align="left">latin1_bin</td>
<td align="left">latin1_swedish_ci</td>
<td align="left">latin1_swedish_ci</td>
</tr>
<tr>
<td align="left">binary</td>
<td align="left">binary</td>
<td align="left">binary</td>
<td align="left">binary</td>
</tr>
</tbody></table>
<p>在 4.0 版本之前，TiDB 中可以任意指定字符集对应的所有 Collation，并把它们按照默认 Collation 处理，即以编码字节序为字符定序。同时，并未像 MySQL 一样，在比较前按照 Collation 的 <code>PADDING</code> 属性将字符补齐空格。因此，会造成以下的行为区别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tidb&gt; create table t(a varchar(20) charset utf8mb4 collate utf8mb4_general_ci primary key);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">tidb&gt; insert into t values (&#x27;A&#x27;);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">tidb&gt; insert into t values (&#x27;a&#x27;);</span><br><span class="line">Query OK, 1 row affected // MySQL 中，由于 utf8mb4_general_ci 大小写不敏感，报错 Duplicate entry &#x27;a&#x27;.</span><br><span class="line">tidb&gt; insert into t1 values (&#x27;a &#x27;);</span><br><span class="line">Query OK, 1 row affected // MySQL 中，由于补齐空格比较，报错 Duplicate entry &#x27;a &#x27;</span><br></pre></td></tr></table></figure>

<p>TiDB 4.0 新增了完整的 Collation 支持框架，允许实现所有 MySQL 中的 Collation，并新增了配置开关 <code>new_collation_enabled_on_first_boostrap</code>，在集群初次初始化时决定是否启用新 Collation 框架。在该配置开关打开之后初始化集群，可以通过 <code>mysql</code>.<code>tidb</code> 表中的 <code>new_collation_enabled</code> 变量确认新 Collation 是否启用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tidb&gt; select VARIABLE_VALUE from mysql.tidb where VARIABLE_NAME=&#x27;new_collation_enabled&#x27;;</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| VARIABLE_VALUE |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| True           |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>在新 Collation 启用后，TiDB 修正了 <code>utf8mb4_general_bin</code> 和 <code>utf8_general_bin</code> 的 <code>PADDING</code> 行为，会将字符串补齐空格后比较；同时支持了 <code>utf8mb4_general_ci</code> 和 <code>utf8_general_ci</code>，这两个 Collation 与 MySQL 保持兼容。</p>
<h4 id="系统时区"><a href="#系统时区" class="headerlink" title="系统时区"></a>系统时区</h4><p>在 MySQL 中，系统时区 <code>system_time_zone</code> 在 MySQL 服务启动时通过 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">环境变量 <code>TZ</code> 或命令行参数 <code>--timezone</code></a> 指定。</p>
<p>对于 TiDB 而言，作为一个分布式数据库，TiDB 需要保证整个集群的系统时区始终一致。因此 TiDB 的系统时区在集群初始化时，由负责初始化的 TiDB 节点环境变量 <code>TZ</code> 决定。集群初始化后，固定在集群状态表 <code>mysql</code>.<code>tidb</code> 中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tidb&gt; select VARIABLE_VALUE from mysql.tidb where VARIABLE_NAME=&#x27;system_tz&#x27;;</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| VARIABLE_VALUE |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">| Asia/Shanghai  |</span><br><span class="line">+<span class="comment">----------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>通过查看 <code>system_time_zone</code> 变量，可以看到该值与状态表中的 <code>system_tz</code> 保持一致：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tidb&gt; select @@system_time_zone;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| @@system_time_zone |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Asia/Shanghai      |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>请注意，这意味着 TiDB 的系统时区在初始化后不再更改。若需要改变集群的时区，可以显式指定 <code>time_zone</code> 系统变量，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tidb&gt; set @@global.time_zone=&#x27;UTC&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="乐观事务"><a href="#乐观事务" class="headerlink" title="乐观事务"></a>乐观事务</h3><p>事务是数据库的基础，提供高效的、支持完整 ACID 的分布式事务更是分布式数据库的立足之本。本章节会首先介绍事务的基本概念，然后介绍 TiDB 基于 Percolator 实现的乐观事务以及在使用上的最佳实践。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>对用户来说，最友好的并发事务执行顺序为每个事务独占整个数据库，并发事务执行的结果与一个个串行执行相同，也就是串行化，能够避免所有的异常情况。但在这种隔离级别下，并发执行的事务性能较差，提供更弱保证的隔离级别能够显著提升系统的性能。根据允许出现的异常，SQL-92 标准定义了 4 种隔离级别：读未提交 (READ UNCOMMITTED)、读已提交 (READ COMMITTED)、可重复读 (REPEATABLE READ)、串行化 (SERIALIZABLE)。详见下表：</p>
<table>
<thead>
<tr>
<th align="left">Isolation Level</th>
<th align="left">Dirty Write</th>
<th align="left">Dirty Read</th>
<th align="left">Fuzzy Read</th>
<th align="left">Phantom</th>
</tr>
</thead>
<tbody><tr>
<td align="left">READ UNCOMMITTED</td>
<td align="left">Not Possible</td>
<td align="left">Possible</td>
<td align="left">Possible</td>
<td align="left">Possible</td>
</tr>
<tr>
<td align="left">READ COMMITTED</td>
<td align="left">Not Possible</td>
<td align="left">Not possible</td>
<td align="left">Possible</td>
<td align="left">Possible</td>
</tr>
<tr>
<td align="left">REPEATABLE READ</td>
<td align="left">Not Possible</td>
<td align="left">Not possible</td>
<td align="left">Not possible</td>
<td align="left">Possible</td>
</tr>
<tr>
<td align="left">SERIALIZABLE</td>
<td align="left">Not Possible</td>
<td align="left">Not possible</td>
<td align="left">Not possible</td>
<td align="left">Not possible</td>
</tr>
</tbody></table>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>数据库有多种并发控制方法，这里只介绍以下两种：</p>
<ul>
<li>乐观并发控制（OCC）：在事务提交阶段检测冲突</li>
<li>悲观并发控制（PCC）：在事务执行阶段检测冲突</li>
</ul>
<p>乐观并发控制期望事务间数据冲突不多，只在提交阶段检测冲突能够获取更高的性能。悲观并发控制更适合数据冲突较多的场景，能够避免乐观事务在这类场景下事务因冲突而回滚的问题，但相比乐观并发控制，在没有数据冲突的场景下，性能相对要差。</p>
<h3 id="TiDB-乐观事务实现"><a href="#TiDB-乐观事务实现" class="headerlink" title="TiDB 乐观事务实现"></a>TiDB 乐观事务实现</h3><p>TiDB 基于 Google <a target="_blank" rel="noopener" href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf">Percolator</a> 实现了支持完整 ACID、基于快照隔离级别（Snapshot Isolation）的分布式乐观事务。TiDB 乐观事务需要将事务的所有修改都保存在内存中，直到提交时才会写入 TiKV 并检测冲突。</p>
<h4 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h4><p>Percolator 使用多版本并发控制（MVCC）来实现快照隔离级别，与可重复读的区别在于整个事务是在一个一致的快照上执行。TiDB 使用 <a target="_blank" rel="noopener" href="https://github.com/pingcap/pd">PD</a> 作为全局授时服务（TSO）来提供单调递增的版本号：</p>
<ul>
<li>事务开始时获取 start timestamp，也是快照的版本号；事务提交时获取 commit timestamp，同时也是数据的版本号</li>
<li>事务只能读到在事务 start timestamp 之前最新已提交的数据</li>
<li>事务在提交时会根据 timestamp 来检测数据冲突</li>
</ul>
<h4 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h4><p>TiDB 使用两阶段提交(Two-Phase Commit）来保证分布式事务的原子性，分为 Prewrite 和 Commit 两个阶段：</p>
<ul>
<li>Prewrite：对事务修改的每个 Key 检测冲突并写入 lock 防止其他事务修改。对于每个事务，TiDB 会从涉及到改动的所有 Key 中选中一个作为当前事务的 Primary Key，事务提交或回滚都需要先修改 Primary Key，以它的提交与否作为整个事务执行结果的标识。</li>
<li>Commit：Prewrite 全部成功后，先同步提交 Primary Key，成功后事务提交成功，其他 Secondary Keys 会异步提交。</li>
</ul>
<p>Percolator 将事务的所有状态都保存在底层支持高可用、强一致性的存储系统中，从而弱化了传统两阶段提交中协调者（Coordinator）的作用，所有的客户端都可以根据存储系统中的事务状态对事务进行提交或回滚。</p>
<h4 id="两阶段提交过程"><a href="#两阶段提交过程" class="headerlink" title="两阶段提交过程"></a>两阶段提交过程</h4><p>事务的两阶段提交过程如下：</p>
<p><img src="https://book.tidb.io/res/session1/chapter6/optimistic-txn/1.png" alt="1.png"></p>
<ol>
<li><p>客户端开始一个事务。</p>
</li>
<li><p>TiDB 向 PD 获取 tso 作为当前事务的 start timestamp。</p>
</li>
<li><p>客户端发起读或写请求。</p>
</li>
<li><p>客户端发起 Commit。</p>
</li>
<li><p>TiDB 开始<strong>两阶段提交</strong>，保证分布式事务的原子性，让数据真正落盘。</p>
<p> i. TiDB 从当前要写入的数据中选择一个 Key 作为当前事务的 Primary Key。</p>
<p> ii. TiDB 并发地向所有涉及的 TiKV 发起 Prewrite 请求。TiKV 收到 Prewrite 请求后，检查数据版本信息是否存在冲突，符合条件的数据会被加锁。</p>
<p> iii. TiDB 收到所有 Prewrite 响应且所有 Prewrite 都成功。</p>
<p> iv. TiDB 向 PD 获取第二个全局唯一递增版本号，定义为本次事务的 commit timestamp。</p>
<p> v. TiDB 向 Primary Key 所在 TiKV 发起第二阶段提交。TiKV 收到 Commit 操作后，检查锁是否存在并清理 Prewrite 阶段留下的锁。</p>
</li>
<li><p>TiDB 向客户端返回事务提交成功的信息。</p>
</li>
<li><p>TiDB 异步清理本次事务遗留的锁信息。</p>
</li>
</ol>
<h3 id="悲观事务"><a href="#悲观事务" class="headerlink" title="悲观事务"></a>悲观事务</h3><p>乐观事务模型在分布式系统中有着极大的性能优势，但为了让 TiDB 的使用方式更加贴近传统单机数据库，更好的适配用户场景，TiDB v3.0 及之后版本在乐观事务模型的基础上实现了悲观事务模型。本文将介绍 TiDB 悲观事务模型特点。</p>
<h4 id="悲观锁解决的问题"><a href="#悲观锁解决的问题" class="headerlink" title="悲观锁解决的问题"></a>悲观锁解决的问题</h4><p>通过支持悲观事务，降低用户修改代码的难度甚至不用修改代码：</p>
<ul>
<li>在 v3.0.8 之前，TiDB 默认使用的乐观事务模式会导致事务提交时因为冲突而失败。为了保证事务的成功率，需要修改应用程序，加上重试的逻辑。</li>
<li>乐观事务模型在冲突严重的场景和重试代价大的场景无法满足用户需求，支持悲观事务可以 弥补这方面的缺陷，拓展 TiDB 的应用场景。</li>
</ul>
<p>以发工资场景为例：对于一个用人单位来说，发工资的过程其实就是从企业账户给多个员工的个人账户转账的过程，一般来说都是批量操作，在一个大的转账事务中可能涉及到成千上万的更新，想象一下如果这个大事务执行的这段时间内，某个个人账户发生了消费（变更），如果这个大事务是乐观事务模型，提交的时候肯定要回滚，涉及上万个个人账户发生消费是大概率事件，如果不做任何处理，最坏的情况是这个大事务永远没办法执行，一直在重试和回滚（饥饿）。</p>
<h4 id="基于-Percolator-的悲观事务"><a href="#基于-Percolator-的悲观事务" class="headerlink" title="基于 Percolator 的悲观事务"></a>基于 Percolator 的悲观事务</h4><p>悲观事务在 Percolator 乐观事务基础上实现，在 Prewrite 之前增加了 Acquire Pessimistic Lock 阶段用于避免 Prewrite 时发生冲突：</p>
<ul>
<li>每个 DML 都会加悲观锁，锁写到 TiKV 里，同样会通过 raft 同步。</li>
<li>悲观事务在加悲观锁时检查各种约束，如 Write Conflict、key 唯一性约束等。</li>
<li>悲观锁不包含数据，只有锁，只用于防止其他事务修改相同的 Key，不会阻塞读，但 Prewrite 后会阻塞读（和 Percolator 相同，但有了大事务支持后将不会阻塞读）。</li>
<li>提交时同 Percolator，悲观锁的存在保证了 Prewrite 不会发生 Write Conflict，保证了提交一定成功。</li>
</ul>
<p><img src="https://book.tidb.io/res/session1/chapter6/pessimistic-txn/1.png" alt="1.png"></p>
<h4 id="等锁顺序"><a href="#等锁顺序" class="headerlink" title="等锁顺序"></a>等锁顺序</h4><p>TiKV 中实现了 <code>Waiter Manager</code> 用于管理等锁的事务，当悲观事务加锁遇到其他事务的锁时，将会进入 <code>Waiter Manager</code> 中等待锁被释放，TiKV 会尽可能按照事务 start timestamp 的顺序来依次获取锁，从而避免事务间无用的竞争。</p>
<h4 id="分布式死锁检测"><a href="#分布式死锁检测" class="headerlink" title="分布式死锁检测"></a>分布式死锁检测</h4><p>在 <code>Waiter Manager</code> 中等待锁的事务间可能发生死锁，而且可能发生在不同的机器上，<code>TiDB</code> 采用分布式死锁检测来解决死锁问题：</p>
<ul>
<li>在整个 TiKV 集群中，有一个死锁检测器 leader。</li>
<li>当要等锁时，其他节点会发送检测死锁的请求给 leader。</li>
</ul>
<p><img src="https://book.tidb.io/res/session1/chapter6/pessimistic-txn/2.png" alt="2.png"></p>
<p>死锁检测器基于 Raft 实现了高可用，等锁事务也会定期发送死锁检测请求给死锁检测器的 leader，从而保证了即使之前 leader 宕机的情况下也能检测到死锁。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/TiDB/">TiDB</a></div><div class="post_share"><div class="social-share" data-image="/img/jump.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/Wechatpay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/Wechatpay.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src="/img/jump.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式事务相关理论基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/01/G1%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="/img/jump.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">G1详解</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Wangpengyu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'silence314/commit-utterances')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>