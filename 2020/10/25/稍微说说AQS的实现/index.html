<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>稍微说说AQS的实现 | 王鹏宇的博客</title><meta name="description" content="之前写Java线程安全集合的文章里有提到AQS，但是感觉因为还要写其他内容，AQS写的不够清楚，这里单独一篇文章讲讲AQS"><meta name="keywords" content="Java,线程安全"><meta name="author" content="Wangpengyu"><meta name="copyright" content="Wangpengyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/25/%E7%A8%8D%E5%BE%AE%E8%AF%B4%E8%AF%B4AQS%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="稍微说说AQS的实现"><meta property="og:url" content="http://example.com/2020/10/25/%E7%A8%8D%E5%BE%AE%E8%AF%B4%E8%AF%B4AQS%E7%9A%84%E5%AE%9E%E7%8E%B0/"><meta property="og:site_name" content="王鹏宇的博客"><meta property="og:description" content="之前写Java线程安全集合的文章里有提到AQS，但是感觉因为还要写其他内容，AQS写的不够清楚，这里单独一篇文章讲讲AQS"><meta property="og:image" content="http://example.com/blogImg/ReentrantLock%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.png"><meta property="article:published_time" content="2020-10-25T07:00:10.000Z"><meta property="article:modified_time" content="2020-10-25T08:10:05.621Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-25 16:10:05'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AbstractQueuedSynchronizer"><span class="toc-number">1.</span> <span class="toc-text">AbstractQueuedSynchronizer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lock"><span class="toc-number">2.</span> <span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">2.1.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">非公平锁&#x2F;公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lock"><span class="toc-number">2.1.1.1.1.</span> <span class="toc-text">lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tryAcquire"><span class="toc-number">2.1.1.1.2.</span> <span class="toc-text">tryAcquire</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#addWaiter"><span class="toc-number">2.1.1.1.3.</span> <span class="toc-text">addWaiter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#acquireQueued"><span class="toc-number">2.1.1.1.4.</span> <span class="toc-text">acquireQueued</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#park%E7%BB%86%E8%8A%82"><span class="toc-number">2.1.1.1.5.</span> <span class="toc-text">park细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E6%96%AD"><span class="toc-number">2.1.1.1.6.</span> <span class="toc-text">打断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E6%B6%88"><span class="toc-number">2.1.1.1.7.</span> <span class="toc-text">取消</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%94%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">解锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">3.</span> <span class="toc-text">ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E9%94%81"><span class="toc-number">3.0.1.</span> <span class="toc-text">写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E9%94%81"><span class="toc-number">3.0.2.</span> <span class="toc-text">读锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.0.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Condition"><span class="toc-number">4.</span> <span class="toc-text">Condition</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/blogImg/ReentrantLock%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王鹏宇的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">稍微说说AQS的实现</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-25T07:00:10.000Z" title="发表于 2020-10-25 15:00:10">2020-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-25T08:10:05.621Z" title="更新于 2020-10-25 16:10:05">2020-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a><strong>AbstractQueuedSynchronizer</strong></h1><p>AQS是JUC下最核心的类，没有之一，所以我们先来分析一下这个类的数据结构。</p>
<p><img src="/blogImg/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="AQS数据结构"></p>
<p>AQS内部是使用了<strong>双向链表</strong>将等待线程链接起来，当发生并发竞争的时候，就会初始化该队列并让线程进入睡眠等待唤醒，同时每个节点会根据是否为共享锁标记状态为<strong>共享模式</strong>或<strong>独占模式</strong>。</p>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p><strong>Lock</strong>是一个接口，提供了加/解锁的通用API，JUC主要提供了两种锁，ReentrantLock和ReentrantReadWriteLock，前者是重入锁，实现Lock接口，后者是读写锁，本身并没有实现Lock接口，而是其内部类ReadLock或WriteLock实现了Lock接口。</p>
<p>先来看看Lock都提供了哪些接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通加锁，不可打断；未获取到锁进入AQS阻塞  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 可打断锁  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 尝试加锁，未获取到锁不阻塞，返回标识  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 带超时时间的尝试加锁  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 解锁  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建一个条件队列  </span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;  </span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p><strong>synchronized</strong>和<strong>ReentrantLock</strong>都是可重入的，后者使用更加灵活，也提供了更多的高级特性，但其本质的实现原理是差不多的（据说synchronized是借鉴了ReentrantLock的实现原理）。</p>
<p>ReentrantLock提供了两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;  </span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>有参构造是根据参数创建<strong>公平锁</strong>或<strong>非公平锁</strong>，而无参构造默认则是<strong>非公平锁</strong>，因为非公平锁性能非常高，并且大部分业务并不需要使用公平锁。</p>
<h4 id="非公平锁-公平锁"><a href="#非公平锁-公平锁" class="headerlink" title="非公平锁/公平锁"></a>非公平锁/公平锁</h4><h5 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h5><p>非公平锁和公平锁在实现上基本一致，只有个别的地方不同，因此下面会采用对比分析方法进行分析。</p>
<p>从lock方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    sync.lock();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>实际上是委托给了内部类Sync，该类实现了AQS（其它组件实现方法也基本上都是这个套路）；由于有公平和非公平两种模式，因此该类又实现了两个子类：<strong>FairSync</strong>和<strong>NonfairSync</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁  </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        acquire(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁  </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   acquire(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里就是公平锁和非公平锁的第一个不同，非公平锁首先会调用CAS将state从0改为1，如果能改成功则表示获取到锁，直接将exclusiveOwnerThread设置为当前线程，不用再进行后续操作；否则则同公平锁一样调用<strong>acquire</strong>方法获取锁，这个是在AQS中实现的模板方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  </span><br><span class="line">        selfInterrupt();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h5><p>这里两种锁唯一不同的实现就是<strong>tryAcquire</strong>方法，先来看非公平锁的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();  </span><br><span class="line">    <span class="keyword">int</span> c = getState();  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;  </span><br><span class="line">            setExclusiveOwnerThread(current);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;  </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  </span><br><span class="line">        setState(nextc);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>state=0表示还没有被线程持有锁，直接通过CAS修改，能修改成功的就获取到锁，修改失败的线程先判断exclusiveOwnerThread是不是当前线程，是则state+1，表示重入次数+1并返回true，加锁成功，否则则返回false表示尝试加锁失败并调用<strong>acquireQueued</strong>入队。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();  </span><br><span class="line">    <span class="keyword">int</span> c = getState();  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  </span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;  </span><br><span class="line">            setExclusiveOwnerThread(current);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  </span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;  </span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  </span><br><span class="line">        setState(nextc);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order  </span></span><br><span class="line">    Node h = head;  </span><br><span class="line">    Node s;  </span><br><span class="line">    <span class="comment">// 首尾不相等且头结点线程不是当前线程则表示需要进入队列  </span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;  </span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>上面就是公平锁的尝试获取锁的代码，可以看到基本和非公平锁的代码是一样的，区别在于<strong>首次</strong>加锁需要判断是否已经有队列存在，没有才去加锁，有则直接返回false。</p>
<h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><p>接着来看<strong>addWaiter</strong>方法，当尝试加锁失败时，首先就会调用该方法创建一个Node节点并添加到队列中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;  </span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);  </span><br><span class="line">    Node pred = tail;  </span><br><span class="line">    <span class="comment">// 尾节点不为null表示已经存在队列，直接将当前线程作为尾节点  </span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        node.prev = pred;  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  </span><br><span class="line">            pred.next = node;  </span><br><span class="line">            <span class="keyword">return</span> node;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 尾结点不存在则表示还没有初始化队列，需要初始化队列  </span></span><br><span class="line">    enq(node);  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 自旋  </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        Node t = tail;  </span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 只会有一个线程设置头节点成功   </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))  </span><br><span class="line">                tail = head;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其它设置头节点失败的都会自旋设置尾节点  </span></span><br><span class="line">            node.prev = t;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  </span><br><span class="line">                t.next = node;  </span><br><span class="line">                <span class="keyword">return</span> t;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里首先传入了一个<strong>独占模式的空节点</strong>，并根据该节点和当前线程创建了一个Node，然后判断是否已经存在队列，若存在则直接入队，否则调用enq方法初始化队列，提高效率。</p>
<p>此处还有一个非常细节的地方，为什么设置尾节点时都要先将之前的尾节点设置为node.pre的值呢，而不是在CAS之后再设置？</p>
<p>比如像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;  </span><br><span class="line"> node.prev = pred;  </span><br><span class="line">    pred.next = node;  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>因为如果这样做的话，在CAS设置完tail后会存在一瞬间的tail.pre=null的情况，而Doug Lea正是考虑到这种情况，不论何时获取tail.pre都不会为null。</p>
<h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><p>接着看<strong>acquireQueued</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line"> <span class="comment">// 为true表示存在需要取消加锁的节点，仅从这段代码可以看出，  </span></span><br><span class="line"> <span class="comment">// 除非发生异常，否则不会存在需要取消加锁的节点。  </span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">// 打断标记，因为调用的是lock方法，所以是不可打断的  </span></span><br><span class="line">     <span class="comment">// （但实际上是打断了的，只不过这里采用了一种**静默**处理方式，稍后分析）  </span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">                setHead(node);  </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                failed = <span class="keyword">false</span>;  </span><br><span class="line">                <span class="keyword">return</span> interrupted;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                interrupted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;  </span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            node.prev = pred = pred.prev;  </span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);  </span><br><span class="line">        pred.next = node;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里就是队列中线程加锁/睡眠的核心逻辑，首先判断刚刚调用addWaiter方法添加到队列的节点是否是头节点，如果是则再次尝试加锁，这个刚刚分析过了，非公平锁在这里就会再次抢一次锁，抢锁成功则设置为head节点并返回打断标记；否则则和公平锁一样调用<strong>shouldParkAfterFailedAcquire</strong>判断是否应该调用park方法进入睡眠。</p>
<h5 id="park细节"><a href="#park细节" class="headerlink" title="park细节"></a>park细节</h5><p>为什么在park前需要这么一个判断呢？因为当前节点的线程进入park后只能被前一个节点唤醒，那前一个节点怎么知道有没有后继节点需要唤醒呢？</p>
<p>因此当前节点在park前需要给前一个节点设置一个标识，即将<strong>waitStatus</strong>设置为<strong>Node.SIGNAL（-1）</strong>，然后自旋一次再走一遍刚刚的流程，若还是没有获取到锁，则调用<strong>parkAndCheckInterrupt</strong>进入睡眠状态。</p>
<h5 id="打断"><a href="#打断" class="headerlink" title="打断"></a>打断</h5><p>读者可能会比较好奇<strong>Thread.interrupted</strong>这个方法是做什么用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是用来判断当前线程是否被打断过，并清除打断标记（若是被打断过则会返回true，并将打断标记设置为false），所以调用lock方法时，通过<strong>interrupt</strong>也是会打断睡眠的线程的，只是Doug Lea做了一个假象，让用户无感知。</p>
<p>但有些场景又需要知道该线程是否被打断过，所以<strong>acquireQueued</strong>最终会返回<strong>interrupted</strong>打断标记，如果是被打断过，则返回的true，并在<strong>acquire</strong>方法中调用<strong>selfInterrupt</strong>再次打断当前线程（将打断标记设置为true）。</p>
<p>推荐阅读：一文搞懂 Java 线程中断。</p>
<p>这里我们对比看看<strong>lockInterruptibly</strong>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))  </span><br><span class="line">        doAcquireInterruptibly(arg);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);  </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  </span><br><span class="line">                setHead(node);  </span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                failed = <span class="keyword">false</span>;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看到区别就在于使用lockInterruptibly加锁被打断后，是直接抛出<strong>InterruptedException</strong>异常，我们可以捕获这个异常进行相应的处理。</p>
<h5 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h5><p>最后来看看<strong>cancelAcquire</strong>是如何取消加锁的，该情况比较特殊，简单了解下即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先将线程置空  </span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// waitStatus &gt; 0表示节点处于取消状态，则直接将当前节点的pre指向在此之前的最后一个有效节点  </span></span><br><span class="line">    Node pred = node.prev;  </span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  </span><br><span class="line">        node.prev = pred = pred.prev;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存前一个节点的下一个节点，如果在此之前存在取消节点，这里就是之前取消被取消节点的头节点  </span></span><br><span class="line">    Node predNext = pred.next;  </span><br><span class="line"></span><br><span class="line">    node.waitStatus = Node.CANCELLED;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前节点是tail节点，则替换尾节点，替换成功则将新的尾结点的下一个节点设置为null；  </span></span><br><span class="line"><span class="comment">// 否则需要判断是将当前节点的下一个节点赋值给最后一个有效节点，还是唤醒下一个节点。  </span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;  </span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">int</span> ws;  </span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;  </span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||  </span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;  </span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            Node next = node.next;  </span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)  </span><br><span class="line">                compareAndSetNext(pred, predNext, next);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            unparkSuccessor(node);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    sync.release(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;  </span><br><span class="line">        Node h = head;  </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)  </span><br><span class="line">            unparkSuccessor(h);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;  </span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();  </span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  </span><br><span class="line">        free = <span class="keyword">true</span>;  </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    setState(c);  </span><br><span class="line">    <span class="keyword">return</span> free;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;  </span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)  </span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">    Node s = node.next;  </span><br><span class="line">    <span class="comment">// 并发情况下，可能已经被其它线程唤醒或已经取消，则从后向前找到最后一个有效节点并唤醒  </span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        s = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)  </span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)  </span><br><span class="line">                s = t;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)  </span><br><span class="line">        LockSupport.unpark(s.thread);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>解锁就比较简单了，先调用<strong>tryRelease</strong>对<strong>state</strong>执行减一操作，如果state==0，则表示完全释放锁；若果存在后继节点，则调用<strong>unparkSuccessor</strong>唤醒后继节点，唤醒后的节点的waitStatus会重新被设置为0。</p>
<p>只是这里有一个小细节，为什么是从后向前找呢？因为我们在开始说过，设置尾节点保证了node.pre不会为null，但pre.next仍有可能是null，所以这里只能从后向前找到最后一个有效节点。</p>
<p><img src="/blogImg/ReentrantLock%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.png" alt="ReentrantLock的加锁流程"></p>
<p>上面是ReentrantLock的加锁流程，可以看到整个流程不算复杂，只是判断和跳转比较多，主要是Doug Lea将代码和性能都优化到了极致，代码非常精简，但细节却非常多。</p>
<p>另外通过上面的分析，我们也可以发现，公平锁和非公平锁的区别就在于<strong>非公平锁不管是否有线程在排队，先抢三次锁，而公平锁则会判断是否存在队列，有线程在排队则直接进入队列排队；另外线程在park被唤醒后非公平锁还会抢锁，公平锁仍然需要排队</strong>，所以非公平锁的性能比公平锁高很多，大部分情况下我们使用非公平锁即可。</p>
<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h1><p>ReentrantLock是一把独占锁，只支持重入，不支持共享，所以JUC包下还提供了<strong>读写锁</strong>，这把锁支持读读并发，但读写、写写都是互斥的。</p>
<p>读写锁也是基于AQS实现的，也包含了一个继承自AQS的内部类Sync，同样也有公平和非公平两种模式，下面主要讨论非公平模式下的读写锁实现。</p>
<p>读写锁实现相对比较复杂，在ReentrantLock中就是使用的int型的state属性来表示锁被某个线程占有和重入次数，而ReentrantReadWriteLock分为了读和写两种锁，要怎么用一个字段表示两种锁的状态呢？</p>
<p>Doug Lea大师将state字段分为了高二字节和低二字节，即高16位用来表示读锁状态，低16位则用来表示写锁，如下图：</p>
<p><img src="/blogImg/ReentrantReadWriteLock.png" alt="ReentrantReadWriteLock"></p>
<p>因为读写锁状态都只用了两个字节，所以可重入的次数最多是65535，当然正常情况下重入是不可能达到这么多的。</p>
<p>那它是怎么实现的呢？还是先从构造方法开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;  </span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();  </span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);  </span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>同样默认就是非公平锁，同时还创建了<strong>readerLock</strong>和<strong>writerLock</strong>两个对象，我们只需要像下面这样就能获取到读写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock r = lock.readLock();  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock w = lock.writeLock();  </span><br></pre></td></tr></table></figure>

<h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>由于写锁的加锁过程相对更简单，下面先从写锁加锁开始分析，入口在ReentrantReadWriteLock#WriteLock.lock()方法，点进去看，发现还是使用的AQS中的acquire方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  </span><br><span class="line">        selfInterrupt();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>所以不同的地方也只有<strong>tryAcquire</strong>方法，我们重点分析这个方法就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;  </span><br><span class="line"><span class="comment">// 65535  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX\_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED\_SHIFT) - <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 低16位是1111....1111  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE\_MASK = (<span class="number">1</span> &lt;&lt; SHARED\_SHIFT) - <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 得到c低16位的值  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  </span><br><span class="line">    Thread current = Thread.currentThread();  </span><br><span class="line">    <span class="keyword">int</span> c = getState();  </span><br><span class="line">    <span class="comment">// 获取写锁加锁和重入的次数  </span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);  </span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 已经有线程持有锁  </span></span><br><span class="line">     <span class="comment">// 这里有两种情况：1. c!=0 &amp;&amp; w==0表示有线程获取了读锁，不论是否是当前线程，直接返回false，  </span></span><br><span class="line">     <span class="comment">// 也就是说读-写锁是不支持升级重入的（但支持写-读降级），原因后文会详细分析；  </span></span><br><span class="line">     <span class="comment">// 2. c!=0 &amp;&amp; w!=0 &amp;&amp; current != getExclusiveOwnerThread()表示有其它线程持有了写锁，写写互斥  </span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 超出65535，抛异常  </span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  </span><br><span class="line">        <span class="comment">// 否则写锁的次数直接加1  </span></span><br><span class="line">        setState(c + acquires);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// c==0才会走到这，但这时存在两种情况，有队列和无队列，所以公平锁和非公平锁处理不同，  </span></span><br><span class="line"><span class="comment">// 前者需要判断是否存在队列，有则尝试加锁失败，无则加锁成功，而非公平锁直接使用CAS加锁即可  </span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||  </span><br><span class="line">        !compareAndSetState(c, c + acquires))  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    setExclusiveOwnerThread(current);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>写锁尝试加锁的过程就分析完了，其余的部分上文已经讲过，这里不再赘述。</p>
<h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  </span><br><span class="line">        doAcquireShared(arg);  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>读锁在加锁开始就和其它锁不同，调用的是<strong>acquireShared</strong>方法，意为获取共享锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED\_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED\_SHIFT);  </span><br><span class="line"><span class="comment">// 右移16位得到读锁状态的值  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;  </span><br><span class="line">     Thread current = Thread.currentThread();  </span><br><span class="line">     <span class="keyword">int</span> c = getState();  </span><br><span class="line">     <span class="comment">// 为什么读写互斥？因为读锁一上来就判断了是否有其它线程持有了写锁（当前线程持有写锁再获取读锁是可以的）  </span></span><br><span class="line">     <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;  </span><br><span class="line">         getExclusiveOwnerThread() != current)  </span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">     <span class="keyword">int</span> r = sharedCount(c);  </span><br><span class="line">     <span class="comment">// 公平锁判断是否存在队列，非公平锁判断第一个节点是不是EXCLUSIVE模式，是的话会返回true  </span></span><br><span class="line">     <span class="comment">// 返回false则需要判断读锁加锁次数是否超过65535，没有则使用CAS给读锁+1  </span></span><br><span class="line">     <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;  </span><br><span class="line">         r &lt; MAX_COUNT &amp;&amp;  </span><br><span class="line">         compareAndSetState(c, c + SHARED_UNIT)) &#123;  </span><br><span class="line">         <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;  </span><br><span class="line">          <span class="comment">// 第一个读锁线程就是当前线程  </span></span><br><span class="line">             firstReader = current;  </span><br><span class="line">             firstReaderHoldCount = <span class="number">1</span>;  </span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;  </span><br><span class="line">          <span class="comment">// 记录读锁的重入  </span></span><br><span class="line">             firstReaderHoldCount++;  </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          <span class="comment">// 获取最后一次加读锁的重入次数记录器HoldCounter  </span></span><br><span class="line">             HoldCounter rh = cachedHoldCounter;  </span><br><span class="line">             <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))  </span><br><span class="line">              <span class="comment">// 当前线程第一次重入需要初始化，以及当前线程和缓存的最后一次记录器的线程id不同，需要从ThreadLocalHoldCounter拿到对应的记录器  </span></span><br><span class="line">                 cachedHoldCounter = rh = readHolds.get();  </span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  </span><br><span class="line">              <span class="comment">// 缓存到ThreadLocal  </span></span><br><span class="line">                 readHolds.set(rh);  </span><br><span class="line">             rh.count++;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> fullTryAcquireShared(current);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这段代码有点复杂，首先需要保证读写互斥，然后进行初次加锁，若加锁失败就会调用fullTryAcquireShared方法进行兜底处理。在初次加锁中与写锁不同的是，写锁的state可以直接用来记录写锁的重入次数，因为写写互斥，但读锁是共享的，state用来记录读锁的加锁次数了，重入次数该怎么记录呢？</p>
<p>重入是指同一线程，那么是不是可以使用ThreadLocl来保存呢？没错，Doug Lea就是这么处理的，新增了一个HoldCounter类，这个类只有线程id和重入次数两个字段，当线程重入的时候就会初始化这个类并保存在<strong>ThreadLocalHoldCounter</strong>类中，这个类就是继承ThreadLocl的，用来初始化HoldCounter对象并保存。</p>
<p>这里还有个小细节，为什么要使用<strong>cachedHoldCounter</strong>缓存最后一次加读锁的<strong>HoldCounter</strong>？</p>
<p>因为大部分情况下，重入和释放锁的线程很有可能就是最后一次加锁的线程，所以这样做能够提高加解锁的效率，Doug Lea真是把性能优化到了极致。</p>
<p>上面只是初次加锁，有可能会加锁失败，就会进入到<strong>fullTryAcquireShared</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;  </span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        <span class="keyword">int</span> c = getState();  </span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)  </span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;  </span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;  </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    rh = cachedHoldCounter;  </span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;  </span><br><span class="line">                        rh = readHolds.get();  </span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  </span><br><span class="line">                            readHolds.remove();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  </span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;  </span><br><span class="line">                firstReader = current;  </span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;  </span><br><span class="line">                firstReaderHoldCount++;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)  </span><br><span class="line">                    rh = cachedHoldCounter;  </span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))  </span><br><span class="line">                    rh = readHolds.get();  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)  </span><br><span class="line">                    readHolds.set(rh);  </span><br><span class="line">                rh.count++;  </span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个方法中代码和<strong>tryAcquireShared</strong>基本上一致，只是采用了自旋的方式，处理初次加锁中的漏网之鱼</p>
<p>上面两个方法若返回大于0则表示加锁成功，小于0则会调用<strong>doAcquireShared</strong>方法，这个就和之前分析的<strong>acquireQueued</strong>差不多了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;  </span><br><span class="line"> <span class="comment">// 先添加一个SHARED类型的节点到队列  </span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);  </span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;  </span><br><span class="line">             <span class="comment">// 再次尝试加读锁  </span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);  </span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                 <span class="comment">// 设置head节点以及传播唤醒后面的读线程  </span></span><br><span class="line">                    setHeadAndPropagate(node, r);  </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC  </span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)  </span><br><span class="line">                        selfInterrupt();  </span><br><span class="line">                    failed = <span class="keyword">false</span>;  </span><br><span class="line">                    <span class="keyword">return</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 只有前一个节点的waitStatus=-1时才会park，=0或者-3（先不考虑-2和1的情况）都会设置为-1后再次自旋尝试加锁，若还是加锁失败就会park  </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  </span><br><span class="line">                parkAndCheckInterrupt())  </span><br><span class="line">                interrupted = <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (failed)  </span><br><span class="line">            cancelAcquire(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;  </span><br><span class="line"> <span class="comment">// 设置头节点  </span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below  </span></span><br><span class="line">    setHead(node);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// propagate是tryAcquireShared的返回值，当前线程加锁成功还要去唤醒后继的共享节点  </span></span><br><span class="line">    <span class="comment">// （其余的判断比较复杂，笔者也还未想明白，知道的读者可以指点一下）  </span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||  </span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        Node s = node.next;  </span><br><span class="line">        <span class="comment">// 判断后继节点是否是共享节点  </span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())  </span><br><span class="line">            doReleaseShared();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">        Node h = head;  </span><br><span class="line">        <span class="comment">// 存在后继节点  </span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;  </span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;  </span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;  </span><br><span class="line">             <span class="comment">// 当前一个节点加锁成功后自然需要将-1改回0，并唤醒后继线程，同时自旋将0改为-2让唤醒传播下去  </span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))  </span><br><span class="line">                    <span class="keyword">continue</span>;          </span><br><span class="line">                unparkSuccessor(h);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 设置头节点的waitStatus=-2，使得唤醒可以传播下去  </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;  </span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))  </span><br><span class="line">                <span class="keyword">continue</span>;               </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (h == head)            </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;  </span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">do</span> &#123;  </span><br><span class="line">            node.prev = pred = pred.prev;  </span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);  </span><br><span class="line">        pred.next = node;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里的逻辑也非常的绕，当多个线程同时调用<strong>addWaiter</strong>添加到队列中后，并且假设这些节点的第一个节点的前一个节点就是head节点，那么第一个节点就能加锁成功（假设都是SHARED节点），其余的节点在第一个节点设置头节点之前都会进入<strong>shouldParkAfterFailedAcquire</strong>方法，这时候waitStatus都等于0，所以继续自旋不会park，若再次加锁还失败就会park（因为这时候waitStatus=-1），但都是读线程的情况下一般都不会出现，因为<strong>setHeadAndPropagate</strong>第一步就是修改head，所以其余SHARED节点最终都能加锁成功并一直将唤醒传播下去。</p>
<p>以上就是读写锁加锁过程，解锁比较简单，这里就不详细分析了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>读写锁将state分为了高二字节和低二字节，分别存储读锁和写锁的状态，实现更为的复杂，在使用上还有几点需要注意：</p>
<ul>
<li>读读共享，但是在读中间穿插了写的话，后面的读都会被阻塞，直到前面的写释放锁后，后面的读才会共享，相关原理看完前文不难理解。</li>
<li>读写锁只支持降级重入，不支持升级重入。因为如果支持升级重入的话，是会出现死锁的。如下面这段代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rw</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    r.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;获取到读锁&quot;</span>);  </span><br><span class="line">        w.lock();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            log.info(<span class="string">&quot;获取到写锁&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            w.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">        r.unlock();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>多个线程访问都能获取到读锁，但读写互斥，彼此都要等待对方的读锁释放才能获取到写锁，这就造成了死锁。</p>
<p>ReentrantReadWriteLock在某些场景下性能上不算高，因此Doug Lea在JDK1.8的时候又提供了一把高性能的读写锁StampedLock，前者读写锁都是悲观锁，而后者提供了新的模式——乐观锁，但它不是基于AQS实现的，本文不进行分析。</p>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a><strong>Condition</strong></h1><p>Lock接口中还有一个方法<strong>newCondition</strong>，这个方法就是创建一个条件队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>所谓条件队列就是创建一个新的ConditionObject对象，这个对象的数据结构在开篇就看过了，包含<strong>首</strong>、<strong>尾</strong>两个节点字段，每当调用Condition#await方法时就会在对应的Condition对象中排队等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  </span><br><span class="line">    <span class="comment">// 加入条件队列  </span></span><br><span class="line">    Node node = addConditionWaiter();  </span><br><span class="line">    <span class="comment">// 因为Condition.await必须配合Lock.lock使用，所以await时就是将已获得锁的线程全部释放掉  </span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);  </span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// 判断是在同步队列还是条件队列，后者则直接park  </span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;  </span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="comment">// 获取打断处理方式（抛出异常或重设标记）  </span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 调用aqs的方法  </span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  </span><br><span class="line">        interruptMode = REINTERRUPT;  </span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled  </span></span><br><span class="line">     <span class="comment">// 清除掉已经进入同步队列的节点  </span></span><br><span class="line">        unlinkCancelledWaiters();  </span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)  </span><br><span class="line">        reportInterruptAfterWait(interruptMode);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Node t = lastWaiter;  </span><br><span class="line">    <span class="comment">// 清除状态为取消的节点  </span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;  </span><br><span class="line">        unlinkCancelledWaiters();  </span><br><span class="line">        t = lastWaiter;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个CONDITION状态的节点并添加到队列末尾  </span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);  </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  </span><br><span class="line">        firstWaiter = node;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        t.nextWaiter = node;  </span><br><span class="line">    lastWaiter = node;  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>await方法实现比较简单，大部分代码都是上文分析过的，这里不再重复。接着来看signal方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();  </span><br><span class="line">    <span class="comment">// 从条件队列第一个节点开始唤醒  </span></span><br><span class="line">    Node first = firstWaiter;  </span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)  </span><br><span class="line">        doSignal(first);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)  </span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;  </span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;  </span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;  </span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;  </span><br><span class="line"> <span class="comment">// 修改waitStatus状态，如果修改失败，则说明该节点已经从条件队列转移到了同步队列  </span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面修改成功，则将该节点添加到同步队列末尾，并返回之前的尾结点  </span></span><br><span class="line">    Node p = enq(node);  </span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;  </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))  </span><br><span class="line">     <span class="comment">// unpark当前线程，结合await方法看  </span></span><br><span class="line">        LockSupport.unpark(node.thread);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>signal的逻辑也比较简单，就是唤醒条件队列中的第一个节点，主要是要结合await的代码一起理解。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">线程安全</a></div><div class="post_share"><div class="social-share" data-image="/blogImg/ReentrantLock%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/Wechatpay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/Wechatpay.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/27/RPC%E5%92%8CHTTP%E8%B0%83%E7%94%A8/"><img class="prev-cover" src="/blogImg/RPC%E6%9E%B6%E6%9E%84.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RPC和HTTP调用</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"><img class="next-cover" src="/blogImg/paxos%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%9B%BE.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式一致性协议</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/08/Java线程安全集合/" title="Java线程安全集合"><img class="cover" src="/blogImg/concurrentHashMap%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-08</div><div class="title">Java线程安全集合</div></div></a></div><div><a href="/2020/09/04/java-线程池/" title="java 线程池"><img class="cover" src="/blogImg/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-04</div><div class="title">java 线程池</div></div></a></div><div><a href="/2020/09/07/JVM和垃圾收集器3/" title="JVM垃圾收集器"><img class="cover" src="/blogImg/ZGC%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-07</div><div class="title">JVM垃圾收集器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wangpengyu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>