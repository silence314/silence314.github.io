<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring类加载过程与生命周期 | 王鹏宇的博客</title><meta name="description" content="这也是实际工作中遇到的一个问题，有一些放在配置里的配置项在MVC升Boot的过程中空指针了！研究了半天原因。。记录一下相关知识"><meta name="keywords" content="Spring,Spring Boot"><meta name="author" content="Wangpengyu"><meta name="copyright" content="Wangpengyu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/10/01/Spring%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="Spring类加载过程与生命周期"><meta property="og:url" content="http://example.com/2020/10/01/Spring%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><meta property="og:site_name" content="王鹏宇的博客"><meta property="og:description" content="这也是实际工作中遇到的一个问题，有一些放在配置里的配置项在MVC升Boot的过程中空指针了！研究了半天原因。。记录一下相关知识"><meta property="og:image" content="http://example.com/blogImg/spring%20boot%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97.png"><meta property="article:published_time" content="2020-10-01T08:06:00.000Z"><meta property="article:modified_time" content="2020-10-06T09:48:18.151Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-06 17:48:18'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">21</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-boot%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">Spring boot源码模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBootApplication%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">@SpringBootApplication注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AutoConfigurationImportSelector"><span class="toc-number">2.1.</span> <span class="toc-text">AutoConfigurationImportSelector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">SpringBoot自动配置原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">自动配置的主要逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoConfigurationImportFilter"><span class="toc-number">2.1.3.</span> <span class="toc-text">AutoConfigurationImportFilter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#createOutcomesResolver"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">createOutcomesResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-StandardOutcomesResolver"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">new StandardOutcomesResolver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StandardOutcomesResolver-resolveOutcomes%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">StandardOutcomesResolver.resolveOutcomes方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadedOutcomesResolver-resolveOutcomes%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">ThreadedOutcomesResolver.resolveOutcomes方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoConfigurationImportListener"><span class="toc-number">2.1.4.</span> <span class="toc-text">AutoConfigurationImportListener</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AutoConfigurationPackages"><span class="toc-number">2.2.</span> <span class="toc-text">AutoConfigurationPackages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EnableConfigurationProperties"><span class="toc-number">3.</span> <span class="toc-text">@EnableConfigurationProperties</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EnableConfigurationPropertiesImportSelector"><span class="toc-number">3.1.</span> <span class="toc-text">EnableConfigurationPropertiesImportSelector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationPropertiesBeanRegistrar"><span class="toc-number">3.1.1.</span> <span class="toc-text">ConfigurationPropertiesBeanRegistrar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationPropertiesBindingPostProcessorRegistrar"><span class="toc-number">3.1.2.</span> <span class="toc-text">ConfigurationPropertiesBindingPostProcessorRegistrar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationBeanFactoryMetadata"><span class="toc-number">3.1.3.</span> <span class="toc-text">ConfigurationBeanFactoryMetadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationPropertiesBindingPostProcessor"><span class="toc-number">3.1.4.</span> <span class="toc-text">ConfigurationPropertiesBindingPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E9%80%BB%E8%BE%91%E5%89%8D%E5%85%88%E5%87%86%E5%A4%87%E5%A5%BD%E7%9B%B8%E5%85%B3%E5%85%83%E6%95%B0%E6%8D%AE%E5%92%8C%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">3.1.5.</span> <span class="toc-text">在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E9%80%BB%E8%BE%91"><span class="toc-number">3.2.</span> <span class="toc-text">执行真正的外部属性绑定逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationPropertiesBinder"><span class="toc-number">3.2.1.</span> <span class="toc-text">ConfigurationPropertiesBinder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96BindHandler%E5%AF%B9%E8%B1%A1%E4%BB%A5%E4%BE%BF%E5%9C%A8%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A%E6%97%B6%E6%9D%A5%E5%A4%84%E7%90%86%E4%B8%80%E4%BA%9B%E9%99%84%E4%BB%B6%E9%80%BB%E8%BE%91"><span class="toc-number">3.2.2.</span> <span class="toc-text">获取BindHandler对象以便在属性绑定时来处理一些附件逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Binder%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BA%8E%E8%BF%9B%E8%A1%8C%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">获取Binder对象用于进行属性绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">4.</span> <span class="toc-text">SpringBoot的启动流程是怎样的</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/blogImg/spring%20boot%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王鹏宇的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-camera-retro"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Spring类加载过程与生命周期</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-01T08:06:00.000Z" title="发表于 2020-10-01 16:06:00">2020-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-06T09:48:18.151Z" title="更新于 2020-10-06 17:48:18">2020-10-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Spring-boot源码模块"><a href="#Spring-boot源码模块" class="headerlink" title="Spring boot源码模块"></a>Spring boot源码模块</h1><img src="/blogImg/spring boot源码模块.png" alt="spring boot源码模块" style="zoom:50%;" />

<p>从上图可以看到，主要有以下四个模块：</p>
<ul>
<li><p><strong>spring-boot-project</strong>：整个SpringBoot框架全部功能在这个模块实现，SpringBoot项目95%的代码都在这里实现，源码总共有25万行左右。</p>
</li>
<li><p><strong>Spring-boot-samples</strong>：这个是SpringBoot给小伙伴们赠送的福利，里面包含了各种各样使用SpringBoot的简单demo，我们调试阅读源码的时候可以充分利用该模块。</p>
</li>
<li><p><strong>Spring-boot-sample-invoker</strong>：这个模块应该是跟sample模块有关，注意根pom.xml中有这么一句话：<code>Samples are built via the invoker plugin</code>，该模块无代码。</p>
</li>
<li><p><strong>Spring-boot-tests</strong>：这个模块SpringBoot的测试模块，跟部署测试和集成测试有关。</p>
<img src="/blogImg/spring boot project.png" alt="spring boot project" style="zoom:50%;" />
</li>
</ul>
<ol>
<li>spring-boot-parent</li>
</ol>
<p>这个模块没有代码，是spring-boot模块的父项目，被其他子模块继承。</p>
<ol start="2">
<li>spring-boot</li>
</ol>
<p>这个模块是SpringBoot项目的核心，可以说一些基础核心的功能都在这里实现，为SpringBoot的其他模块组件功能提供了支持，主要包括以下核心功能：</p>
<ul>
<li><code>SpringApplication</code>类，这个是SpringBoot的启动类，提供了一个静态的<code>run</code>方法来启动程序，该类主要用来创建并且刷新Spring容器<code>ApplicationContext</code>.</li>
<li>支持选择不同的容器比如Tomcat,Jetty等来作为应用的嵌入容器，这个是SpringBoot的新特性之一。</li>
<li>外部配置支持，这个指的是我们执行<code>java -jar xxx.jar</code>命令时可以带一些参数，比如执行<code>java -jar demo.jar --server.port=8888</code>来将应用端口修改为8888.</li>
<li>该模块内置了一些SpringBoot启动时的生命周期事件和一些容器初始化器(<code>ApplicationContext</code> initializers)，来执行一些SpringBoot启动时的初始化逻辑。</li>
</ul>
<ol start="3">
<li>spring-boot-autoconfigure</li>
</ol>
<p>这个模块跟SpringBoot的自动配置有关，也是SpringBoot的新特性之一。比如SpringBoot能基于类路径来自动配置某个项目模块，自动配置最为关键的注解是<code>@EnableAutoConfiguration</code>,这个注解能触发Spring上下文的自动配置。另外一个重要的注解是<code>@Conditional</code>。</p>
<blockquote>
<p>举个栗子，若<code>HSQLDB</code>在项目的类路径中，且我们没有配置任何其他数据库的连接，此时自动配置就会自动根据类路径来创建相应的<code>bean</code>。</p>
</blockquote>
<p>除了根据类路径来进行自动配置外，还有根据容器中是否存在某个bean等方式来进行自动配置，这里不会进入到具体细节中。</p>
<ol start="4">
<li>spring-boot-starters</li>
</ol>
<p>这个模块是跟SpringBoot的起步依赖有关，也是SpringBoot的新特性之一。SpringBoot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖其实就是利用maven项目模型将其他相关的依赖给聚合起来，里面各种依赖的版本号都给定义好，避免用户在引入依赖时出现各种版本冲突，方便了我们的使用。</p>
<blockquote>
<p>举个栗子，我们要用到activemq时，此时可以直接引入<code>spring-boot-starter-activemq</code>起步依赖即可，若SpringBoot官网或第三方组织没有提供相应的SpringBoot起步依赖时，此时我们可以进行定制自己的起步依赖。</p>
</blockquote>
<p>注意，该模块没有代码，主要是通过maven的pom.xml来组织各种依赖。</p>
<ol start="5">
<li>spring-boot-cli</li>
</ol>
<p>Spring Boot CLI是一个命令行工具，如果您想使用Spring快速开发，可以使用它。它允许您运行Groovy脚本，这意味着您有一个熟悉的类似Java的语法，而没有那么多样板代码。您还可以引导一个新项目或编写自己的命令。</p>
<ol start="6">
<li>spring-boot-actuator</li>
</ol>
<p>这个跟SpringBoot的监控有关，也是SpringBoot的新特性之一。可以通过HTTP端点或JMX等来管理和监控应用。审计、运行状况和度量收集可以自动应用到应用程序。这个监控模块是开箱即用的，提供了一系列端点包括<code>HealthEndpoint</code>, <code>EnvironmentEndpoint</code>和<code>BeansEndpoint</code>等端点。</p>
<ol start="7">
<li>spring-boot-actuator-autoconfigure</li>
</ol>
<p>这个模块为监控模块提供自动配置的功能，通常也是根据类路径来进行配置。比如<code>Micrometer</code>存在于类路径中，那么将会自动配置<code>MetricsEndpoint</code>。</p>
<ol start="8">
<li>spring-boot-test</li>
</ol>
<p>这个模式是spring-boot的跟测试有关的模块，包含了一些帮助我们测试的核心类和注解（比如<code>@SpringBootTest</code>）。</p>
<ol start="9">
<li>spring-boot-dependencies</li>
</ol>
<p>这个模块也没有代码，主要是定义了一些SpringBoot的maven相关的一些依赖及其版本。</p>
<ol start="10">
<li>spring-boot-devtools</li>
</ol>
<p>这个模块跟SpringBoot的热部署有关，即修改代码后无需重启应用即生效。</p>
<ol start="11">
<li>spring-boot-docs</li>
</ol>
<p>这个模块应该是跟文档相关的模块。</p>
<ol start="12">
<li>spring-boot-properties-migrator</li>
</ol>
<p>看到 migrator 这个单词，估计就是跟项目迁移有关，没有去细究。</p>
<ol start="13">
<li>spring-boot-test-autoconfigure</li>
</ol>
<p>这个模块一看就是跟SpringBoot的测试的自动配置有关。</p>
<ol start="14">
<li>spring-boot-tools</li>
</ol>
<p>这个模块一看就是SpringBoot的工具相关的模块，提供了加载，maven插件,metadata和后置处理相关的支持。</p>
<h1 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h1><p>在开始前，我们先想一下，SpringBoot为何一个标注有<code>@SpringBootApplication</code>注解的启动类通过执行一个简单的<code>run</code>方法就能实现SpringBoot大量<code>Starter</code>的自动配置呢？ 其实SpringBoot的自动配置就跟<code>@SpringBootApplication</code>这个注解有关，我们先来看下其这个注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> </span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; </span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"><span class="comment">// ...省略非关键代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootApplication</code>标注了很多注解，我们可以看到其中跟SpringBoot自动配置有关的注解就有一个即<code>@EnableAutoConfiguration</code>，因此，可以肯定的是SpringBoot的自动配置肯定跟<code>@EnableAutoConfiguration</code>息息相关(其中<code>@ComponentScan</code>注解的<code>excludeFilters</code>属性也有一个类<code>AutoConfigurationExcludeFilter</code>,这个类跟自动配置也有点关系，但不是我们关注的重点)。 现在我们来打开<code>@EnableAutoConfiguration</code>注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>@EnableAutoConfiguration</code>注解又标有<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code>两个注解，顾名思义，<code>@AutoConfigurationPackage</code>注解肯定跟自动配置的包有关，而<code>AutoConfigurationImportSelector</code>则是跟SpringBoot的自动配置选择导入有关（Spring中的<code>ImportSelector</code>是用来导入配置类的，通常是基于某些条件注解<code>@ConditionalOnXxxx</code>来决定是否导入某个配置类）。</p>
<p>因此，可以看出<code>AutoConfigurationImportSelector</code>类是我们本篇的重点，因为SpringBoot的自动配置肯定有一个配置类，而这个配置类的导入则需要靠<code>AutoConfigurationImportSelector</code>这个哥们来实现。</p>
<p>接下来我们重点来看<code>AutoConfigurationImportSelector</code>这个类，完了我们再简单分析下<code>@AutoConfigurationPackage</code>这个注解的逻辑。</p>
<h2 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h2><p>可以肯定的是SpringBoot的自动配置的逻辑肯定与AutoConfigurationImportSelector这个类有关，那么我们该如何去找到SpringBoot自动配置实现逻辑的入口方法呢？</p>
<p>在找SpringBoot自动配置实现逻辑的入口方法前，我们先来看下<code>AutoConfigurationImportSelector</code>的相关类图，好有个整体的理解。看下图：</p>
<p><img src="/blogImg/AutoConfigurationImportSelector%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9B%BE.png" alt="AutoConfigurationImportSelector相关类图"></p>
<p>可以看到<code>AutoConfigurationImportSelector</code>重点是实现了<code>DeferredImportSelector</code>接口和各种<code>Aware</code>接口，然后<code>DeferredImportSelector</code>接口又继承了<code>ImportSelector</code>接口。</p>
<p>自然而然的，我们会去关注<code>AutoConfigurationImportSelector</code>复写<code>DeferredImportSelector</code>接口的实现方法<code>selectImports</code>方法，因为<code>selectImports</code>方法跟导入自动配置类有关，而这个方法往往是程序执行的入口方法。经过调试发现<code>selectImports</code>方法很具有迷惑性，<code>selectImports</code>方法跟自动配置相关的逻辑有点关系，但实质关系不大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">	&#125;</span><br><span class="line">	AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">			.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">			annotationMetadata);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时剧情的发展好像不太符合常理，此时我们又该如何来找到自动配置逻辑有关的入口方法呢？</p>
<p>最简单的方法就是在<code>AutoConfigurationImportSelector</code>类的每个方法都打上断点，然后调试看先执行到哪个方法。但是我们可以不这么做，我们回想下，自定义一个<code>Starter</code>的时候我们是不是要在<code>spring.factories</code>配置文件中配置</p>
<p><code>EnableAutoConfiguration=XxxAutoConfiguration</code></p>
<p>因此可以推断，SpringBoot的自动配置原理肯定跟从<code>spring.factories</code>配置文件中加载自动配置类有关，于是结合<code>AutoConfigurationImportSelector</code>的方法注释，我们找到了<code>getAutoConfigurationEntry</code>方法。于是我们在这个方法里面打上一个断点，此时通过调用栈帧来看下更上层的入口方法在哪里，然后我们再从跟自动配置相关的更上层的入口方法开始分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoConfigurationMetadata the auto-configuration metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blogImg/%E6%96%AD%E7%82%B9.png" alt="断点"></p>
<p>通过上图我们可以看到，跟自动配置逻辑相关的入口方法在<code>DeferredImportSelectorGrouping</code>类的<code>getImports</code>方法处，因此我们就从<code>DeferredImportSelectorGrouping</code>类的<code>getImports</code>方法来开始分析SpringBoot的自动配置源码好了。</p>
<h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p>既然找到<code>ConfigurationClassParser.getImports()方法</code>是自动配置相关的入口方法，那么下面我们就来真正分析SpringBoot自动配置的源码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassParser.java</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line">    <span class="comment">// 遍历DeferredImportSelectorHolder对象集合deferredImports，deferredImports集合装了各种ImportSelector，当然这里装的是AutoConfigurationImportSelector</span></span><br><span class="line">    <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="keyword">this</span>.deferredImports) &#123;</span><br><span class="line">    	<span class="comment">// 【1】，利用AutoConfigurationGroup的process方法来处理自动配置的相关逻辑，决定导入哪些配置类（这个是我们分析的重点，自动配置的逻辑全在这了）</span></span><br><span class="line">    	<span class="keyword">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">    			deferredImport.getImportSelector());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【2】，经过上面的处理后，然后再进行选择导入哪些配置类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.group.selectImports();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.group.process(deferredImport.getConfigurationClass().getMetadata(),         deferredImport.getImportSelector())</code>；主要做的事情就是在<code>this.group</code>即<code>AutoConfigurationGroup</code>对象的<code>process</code>方法中，传入的<code>AutoConfigurationImportSelector</code>对象来选择一些符合条件的自动配置类，过滤掉一些不符合条件的自动配置类。</p>
<p>注：</p>
<ol>
<li><code>AutoConfigurationGroup</code>：是<code>AutoConfigurationImportSelector</code>的内部类，主要用来处理自动配置相关的逻辑，拥有<code>process</code>和<code>selectImports</code>方法，然后拥有<code>entries</code>和<code>autoConfigurationEntries</code>集合属性，这两个集合分别存储被处理后的符合条件的自动配置类，我们知道这些就足够了；</li>
<li><code>AutoConfigurationImportSelector</code>：承担自动配置的绝大部分逻辑，负责选择一些符合条件的自动配置类；</li>
<li><code>metadata</code>:标注在SpringBoot启动类上的<code>@SpringBootApplication</code>注解元数据</li>
</ol>
<h3 id="自动配置的主要逻辑"><a href="#自动配置的主要逻辑" class="headerlink" title="自动配置的主要逻辑"></a>自动配置的主要逻辑</h3><p>继续深究上面 <code>this.group.process</code>方法是如何处理自动配置相关逻辑的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector$AutoConfigurationGroup.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用来处理自动配置类，比如过滤掉不符合匹配条件的自动配置类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">		DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">	Assert.state(</span><br><span class="line">			deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">			() -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">					AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">					deferredImportSelector.getClass().getName()));</span><br><span class="line">	<span class="comment">// 【1】,调用getAutoConfigurationEntry方法得到自动配置类放入autoConfigurationEntry对象中</span></span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">			.getAutoConfigurationEntry(getAutoConfigurationMetadata(),</span><br><span class="line">					annotationMetadata);</span><br><span class="line">	<span class="comment">// 【2】，又将封装了自动配置类的autoConfigurationEntry对象装进autoConfigurationEntries集合</span></span><br><span class="line">	<span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry); </span><br><span class="line">	<span class="comment">// 【3】，遍历刚获取的自动配置类</span></span><br><span class="line">	<span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">		<span class="comment">// 这里符合条件的自动配置类作为key，annotationMetadata作为值放进entries集合</span></span><br><span class="line">		<span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中我们再来看标<code>【1】</code>的方法<code>getAutoConfigurationEntry</code>，这个方法主要是用来获取自动配置类有关，承担了自动配置的主要逻辑。直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">		AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取是否有配置spring.boot.enableautoconfiguration属性，默认返回true</span></span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得@Congiguration标注的Configuration类即被审视introspectedClass的注解数据，</span></span><br><span class="line">	<span class="comment">// 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)</span></span><br><span class="line">	<span class="comment">// 将会获取到exclude = FreeMarkerAutoConfiguration.class和excludeName=&quot;&quot;的注解数据</span></span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">	<span class="comment">// 【1】得到spring.factories文件配置的所有自动配置类</span></span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">			attributes);</span><br><span class="line">	<span class="comment">// 利用LinkedHashSet移除重复的配置类</span></span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">	<span class="comment">// 得到要排除的自动配置类，比如注解属性exclude的配置类</span></span><br><span class="line">	<span class="comment">// 比如：@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)</span></span><br><span class="line">	<span class="comment">// 将会获取到exclude = FreeMarkerAutoConfiguration.class的注解数据</span></span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	<span class="comment">// 检查要被排除的配置类，因为有些不是自动配置类，故要抛出异常</span></span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	<span class="comment">// 【2】将要排除的配置类移除</span></span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	<span class="comment">// 【3】因为从spring.factories文件获取的自动配置类太多，如果有些不必要的自动配置类都加载进内存，会造成内存浪费，因此这里需要进行过滤</span></span><br><span class="line">	<span class="comment">// 注意这里会调用AutoConfigurationImportFilter的match方法来判断是否符合@ConditionalOnBean,@ConditionalOnClass或@ConditionalOnWebApplication，后面会重点分析一下</span></span><br><span class="line">	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">	<span class="comment">// 【4】获取了符合条件的自动配置类后，此时触发AutoConfigurationImportEvent事件，</span></span><br><span class="line">	<span class="comment">// 目的是告诉ConditionEvaluationReport条件评估报告器对象来记录符合条件的自动配置类</span></span><br><span class="line">	<span class="comment">// 该事件什么时候会被触发？--&gt; 在刷新容器时调用invokeBeanFactoryPostProcessors后置处理器时触发</span></span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="comment">// 【5】将符合条件和要排除的自动配置类封装进AutoConfigurationEntry对象，并返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutoConfigurationEntry</code>方法主要做的事情就是获取符合条件的自动配置类，避免加载不必要的自动配置类从而造成内存浪费。我们下面总结下<code>AutoConfigurationEntry</code>方法主要做的事情：</p>
<ol>
<li>【1】从<code>spring.factories</code>配置文件中加载<code>EnableAutoConfiguration</code>自动配置类（注意此时是从<strong>缓存</strong>中拿到的哈）,获取的自动配置类如图3所示。</li>
<li>【2】若<code>@EnableAutoConfiguration</code>等注解标有要<code>exclude</code>的自动配置类，那么再将这个自动配置类排除掉；</li>
<li>【3】排除掉要<code>exclude</code>的自动配置类后，然后再调用<code>filter</code>方法进行进一步的过滤，再次排除一些不符合条件的自动配置类；<strong>这个在稍后会详细分析。</strong></li>
<li>【4】经过重重过滤后，此时再触发<code>AutoConfigurationImportEvent</code>事件，告诉<code>ConditionEvaluationReport</code>条件评估报告器对象来记录符合条件的自动配置类；</li>
<li>【5】 最后再将符合条件的自动配置类返回。</li>
</ol>
<p>总结了<code>AutoConfigurationEntry</code>方法主要的逻辑后，我们再来细看一下<code>AutoConfigurationImportSelector</code>的<code>filter</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">			AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	<span class="comment">// 将从spring.factories中获取的自动配置类转出字符串数组</span></span><br><span class="line">	String[] candidates = StringUtils.toStringArray(configurations);</span><br><span class="line">	<span class="comment">// 定义skip数组，是否需要跳过。注意skip数组与candidates数组顺序一一对应</span></span><br><span class="line">	<span class="keyword">boolean</span>[] skip = <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length];</span><br><span class="line">	<span class="keyword">boolean</span> skipped = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// getAutoConfigurationImportFilters方法：拿到OnBeanCondition，OnClassCondition和OnWebApplicationCondition</span></span><br><span class="line">	<span class="comment">// 然后遍历这三个条件类去过滤从spring.factories加载的大量配置类</span></span><br><span class="line">	<span class="keyword">for</span> (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123;</span><br><span class="line">		<span class="comment">// 调用各种aware方法，将beanClassLoader,beanFactory等注入到filter对象中，</span></span><br><span class="line">		<span class="comment">// 这里的filter对象即OnBeanCondition，OnClassCondition或OnWebApplicationCondition</span></span><br><span class="line">		invokeAwareMethods(filter);</span><br><span class="line">		<span class="comment">// 判断各种filter来判断每个candidate（这里实质要通过candidate(自动配置类)拿到其标注的</span></span><br><span class="line">		<span class="comment">// @ConditionalOnClass,@ConditionalOnBean和@ConditionalOnWebApplication里面的注解值）是否匹配，</span></span><br><span class="line">		<span class="comment">// 注意candidates数组与match数组一一对应</span></span><br><span class="line">		<span class="comment">/**********************【主线，重点关注】********************************/</span></span><br><span class="line">		<span class="keyword">boolean</span>[] match = filter.match(candidates, autoConfigurationMetadata);</span><br><span class="line">		<span class="comment">// 遍历match数组，注意match顺序跟candidates的自动配置类一一对应</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; match.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 若有不匹配的话</span></span><br><span class="line">			<span class="keyword">if</span> (!match[i]) &#123;</span><br><span class="line">				<span class="comment">// 不匹配的将记录在skip数组，标志skip[i]为true，也与candidates数组一一对应</span></span><br><span class="line">				skip[i] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 因为不匹配，将相应的自动配置类置空</span></span><br><span class="line">				candidates[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// 标注skipped为true</span></span><br><span class="line">				skipped = <span class="keyword">true</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 这里表示若所有自动配置类经过OnBeanCondition，OnClassCondition和OnWebApplicationCondition过滤后，全部都匹配的话，则全部原样返回</span></span><br><span class="line">	<span class="keyword">if</span> (!skipped) &#123;</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 建立result集合来装匹配的自动配置类</span></span><br><span class="line">	List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates.length); </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">		<span class="comment">// 若skip[i]为false，则说明是符合条件的自动配置类，此时添加到result集合中</span></span><br><span class="line">		<span class="keyword">if</span> (!skip[i]) &#123; </span><br><span class="line">			result.add(candidates[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印日志</span></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		<span class="keyword">int</span> numberFiltered = configurations.size() - result.size();</span><br><span class="line">		logger.trace(<span class="string">&quot;Filtered &quot;</span> + numberFiltered + <span class="string">&quot; auto configuration class in &quot;</span></span><br><span class="line">				+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)</span><br><span class="line">				+ <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后返回符合条件的自动配置类</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutoConfigurationImportSelector</code>的<code>filter</code>方法主要做的事情就是调用<code>AutoConfigurationImportFilter</code>接口的<code>match</code>方法来判断每一个自动配置类上的条件注解（若有的话）<code>@ConditionalOnClass</code>,<code>@ConditionalOnBean</code>或<code>@ConditionalOnWebApplication</code>是否满足条件，若满足，则返回true，说明匹配，若不满足，则返回false说明不匹配。</p>
<p>这里继续深究前面分析SpringBoot自动配置原理这节标<code>【2】</code>处的 <code>this.group.selectImports</code>方法是如何进一步有选择的导入自动配置类的。直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector$AutoConfigurationGroup.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Entry&gt; <span class="title">selectImports</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.autoConfigurationEntries.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 这里得到所有要排除的自动配置类的set集合</span></span><br><span class="line">	Set&lt;String&gt; allExclusions = <span class="keyword">this</span>.autoConfigurationEntries.stream()</span><br><span class="line">			.map(AutoConfigurationEntry::getExclusions)</span><br><span class="line">			.flatMap(Collection::stream).collect(Collectors.toSet());</span><br><span class="line">	<span class="comment">// 这里得到经过滤后所有符合条件的自动配置类的set集合</span></span><br><span class="line">	Set&lt;String&gt; processedConfigurations = <span class="keyword">this</span>.autoConfigurationEntries.stream() </span><br><span class="line">			.map(AutoConfigurationEntry::getConfigurations)</span><br><span class="line">			.flatMap(Collection::stream)</span><br><span class="line">			.collect(Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>));</span><br><span class="line">	<span class="comment">// 移除掉要排除的自动配置类</span></span><br><span class="line">	processedConfigurations.removeAll(allExclusions); </span><br><span class="line">	<span class="comment">// 对标注有@Order注解的自动配置类进行排序，</span></span><br><span class="line">	<span class="keyword">return</span> sortAutoConfigurations(processedConfigurations,</span><br><span class="line">			getAutoConfigurationMetadata())</span><br><span class="line">					.stream()</span><br><span class="line">					.map((importClassName) -&gt; <span class="keyword">new</span> Entry(</span><br><span class="line">							<span class="keyword">this</span>.entries.get(importClassName), importClassName))</span><br><span class="line">					.collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>selectImports</code>方法主要是针对经过排除掉<code>exclude</code>的和被<code>AutoConfigurationImportFilter</code>接口过滤后的满足条件的自动配置类再进一步排除<code>exclude</code>的自动配置类，然后再排序。逻辑很简单，不再详述。</p>
<p>不过有个疑问，前面已经<code>exclude</code>过一次了，为何这里还要再<code>exclude</code>一次？</p>
<h3 id="AutoConfigurationImportFilter"><a href="#AutoConfigurationImportFilter" class="headerlink" title="AutoConfigurationImportFilter"></a>AutoConfigurationImportFilter</h3><p>这里继续深究前面 4.1节的 <code>AutoConfigurationImportSelector.filter</code>方法的过滤自动配置类的<code>boolean[] match = filter.match(candidates, autoConfigurationMetadata);</code>这句代码。</p>
<p>因此我们继续分析<code>AutoConfigurationImportFilter</code>接口，分析其<code>match</code>方法，同时也是对前一篇<code>@ConditionalOnXxx</code>的源码分析文章中留下的坑进行填补。</p>
<p><code>AutoConfigurationImportFilter</code>接口只有一个<code>match</code>方法用来过滤不符合条件的自动配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoConfigurationImportFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] match(String[] autoConfigurationClasses,</span><br><span class="line">    		AutoConfigurationMetadata autoConfigurationMetadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，在分析<code>AutoConfigurationImportFilter</code>接口的<code>match</code>方法前，我们先来看下其类关系图：</p>
<img src="/blogImg/AutoConfigurationImportFilter.png" alt="AutoConfigurationImportFilter" style="zoom:50%;" />

<p>可以看到,<code>AutoConfigurationImportFilter</code>接口有一个具体的实现类<code>FilteringSpringBootCondition</code>，<code>FilteringSpringBootCondition</code>又有三个具体的子类：<code>OnClassCondition</code>,<code>OnBeanCondtition</code>和<code>OnWebApplicationCondition</code>。</p>
<p>那么这几个类之间的关系是怎样的呢？</p>
<p><code>FilteringSpringBootCondition</code>实现了<code>AutoConfigurationImportFilter</code>接口的<code>match</code>方法，然后在<code>FilteringSpringBootCondition</code>的<code>match</code>方法调用<code>getOutcomes</code>这个抽象模板方法返回自动配置类的匹配与否的信息。同时，最重要的是<code>FilteringSpringBootCondition</code>的三个子类<code>OnClassCondition</code>,<code>OnBeanCondtition</code>和<code>OnWebApplicationCondition</code>将会复写这个模板方法实现自己的匹配判断逻辑。</p>
<p>好了，<code>AutoConfigurationImportFilter</code>接口的整体关系已经清楚了，现在我们再进入其具体实现类<code>FilteringSpringBootCondition</code>的<code>match</code>方法看看是其如何根据条件过滤自动配置类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span>[] match(String[] autoConfigurationClasses,</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">	<span class="comment">// 创建评估报告</span></span><br><span class="line">	ConditionEvaluationReport report = ConditionEvaluationReport</span><br><span class="line">			.find(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">	<span class="comment">// 注意getOutcomes是模板方法，将spring.factories文件种加载的所有自动配置类传入</span></span><br><span class="line">	<span class="comment">// 子类（这里指的是OnClassCondition,OnBeanCondition和OnWebApplicationCondition类）去过滤</span></span><br><span class="line">	<span class="comment">// 注意outcomes数组存储的是不匹配的结果，跟autoConfigurationClasses数组一一对应</span></span><br><span class="line">	<span class="comment">/*****************************【主线，重点关注】*********************************************/</span></span><br><span class="line">	ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses,</span><br><span class="line">			autoConfigurationMetadata);</span><br><span class="line">	<span class="keyword">boolean</span>[] match = <span class="keyword">new</span> <span class="keyword">boolean</span>[outcomes.length];</span><br><span class="line">	<span class="comment">// 遍历outcomes,这里outcomes为null则表示匹配，不为null则表示不匹配</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outcomes.length; i++) &#123;</span><br><span class="line">		ConditionOutcome outcome = outcomes[i];</span><br><span class="line">		match[i] = (outcome == <span class="keyword">null</span> || outcome.isMatch());</span><br><span class="line">		<span class="keyword">if</span> (!match[i] &amp;&amp; outcomes[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 这里若有某个类不匹配的话，此时调用父类SpringBootCondition的logOutcome方法打印日志</span></span><br><span class="line">			logOutcome(autoConfigurationClasses[i], outcomes[i]);</span><br><span class="line">			<span class="comment">// 并将不匹配情况记录到report</span></span><br><span class="line">			<span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">				report.recordConditionEvaluation(autoConfigurationClasses[i], <span class="keyword">this</span>,</span><br><span class="line">						outcomes[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FilteringSpringBootCondition</code>的<code>match</code>方法主要做的事情还是调用抽象模板方法<code>getOutcomes</code>来根据条件来过滤自动配置类，而复写<code>getOutcomes</code>模板方法的有三个子类，这里不再一一分析，<strong>只挑选<code>OnClassCondition</code>复写的<code>getOutcomes</code>方法进行分析。</strong></p>
<p>先直接上<code>OnClassCondition</code>复写的<code>getOutcomes</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata) &#123;</span><br><span class="line">	<span class="comment">// Split the work and perform half in a background thread. Using a single</span></span><br><span class="line">	<span class="comment">// additional thread seems to offer the best performance. More threads make</span></span><br><span class="line">	<span class="comment">// things worse</span></span><br><span class="line">	<span class="comment">// 这里经过测试用两个线程去跑的话性能是最好的，大于两个线程性能反而变差</span></span><br><span class="line">	<span class="keyword">int</span> split = autoConfigurationClasses.length / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 【1】开启一个新线程去扫描判断已经加载的一半自动配置类</span></span><br><span class="line">	OutcomesResolver firstHalfResolver = createOutcomesResolver(</span><br><span class="line">			autoConfigurationClasses, <span class="number">0</span>, split, autoConfigurationMetadata);</span><br><span class="line">	<span class="comment">// 【2】这里用主线程去扫描判断已经加载的一半自动配置类</span></span><br><span class="line">	OutcomesResolver secondHalfResolver = <span class="keyword">new</span> StandardOutcomesResolver(</span><br><span class="line">			autoConfigurationClasses, split, autoConfigurationClasses.length,</span><br><span class="line">			autoConfigurationMetadata, getBeanClassLoader());</span><br><span class="line">	<span class="comment">// 【3】先让主线程去执行解析一半自动配置类是否匹配条件</span></span><br><span class="line">	ConditionOutcome[] secondHalf = secondHalfResolver.resolveOutcomes();</span><br><span class="line">	<span class="comment">// 【4】这里用新开启的线程取解析另一半自动配置类是否匹配</span></span><br><span class="line">	<span class="comment">// 注意为了防止主线程执行过快结束，resolveOutcomes方法里面调用了thread.join()来</span></span><br><span class="line">	<span class="comment">// 让主线程等待新线程执行结束，因为后面要合并两个线程的解析结果</span></span><br><span class="line">	ConditionOutcome[] firstHalf = firstHalfResolver.resolveOutcomes();</span><br><span class="line">	<span class="comment">// 新建一个ConditionOutcome数组来存储自动配置类的筛选结果</span></span><br><span class="line">	ConditionOutcome[] outcomes = <span class="keyword">new</span> ConditionOutcome[autoConfigurationClasses.length];</span><br><span class="line">	<span class="comment">// 将前面两个线程的筛选结果分别拷贝进outcomes数组</span></span><br><span class="line">	System.arraycopy(firstHalf, <span class="number">0</span>, outcomes, <span class="number">0</span>, firstHalf.length);</span><br><span class="line">	System.arraycopy(secondHalf, <span class="number">0</span>, outcomes, split, secondHalf.length);</span><br><span class="line">	<span class="comment">// 返回自动配置类的筛选结果</span></span><br><span class="line">	<span class="keyword">return</span> outcomes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>OnClassCondition</code>的<code>getOutcomes</code>方法主要解析自动配置类是否符合匹配条件，当然这个匹配条件指自动配置类上的注解<code>@ConditionalOnClass</code>指定的类存不存在于<code>classpath</code>中，存在则返回匹配，不存在则返回不匹配。</p>
<p>由于解析自动配置类是否匹配比较耗时，因此从上面代码中我们可以看到分别创建了<code>firstHalfResolver</code>和<code>secondHalfResolver</code>两个解析对象，这两个解析对象个分别对应一个线程去解析加载的自动配置类是否符合条件，最终将两个线程的解析自动配置类的匹配结果合并后返回。</p>
<p>那么自动配置类是否符合条件的解析判断过程又是怎样的呢？现在我们分别来看一下上面代码注释标注的<code>【1】</code>，<code>【2】</code>，<code>【3】</code>和<code>【4】</code>处。</p>
<h4 id="createOutcomesResolver"><a href="#createOutcomesResolver" class="headerlink" title="createOutcomesResolver"></a>createOutcomesResolver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> OutcomesResolver <span class="title">createOutcomesResolver</span><span class="params">(String[] autoConfigurationClasses,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> start, <span class="keyword">int</span> end, AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个StandardOutcomesResolver对象</span></span><br><span class="line">	OutcomesResolver outcomesResolver = <span class="keyword">new</span> StandardOutcomesResolver(</span><br><span class="line">			autoConfigurationClasses, start, end, autoConfigurationMetadata,</span><br><span class="line">			getBeanClassLoader());</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// new一个ThreadedOutcomesResolver对象，并将StandardOutcomesResolver类型的outcomesResolver对象作为构造器参数传入</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ThreadedOutcomesResolver(outcomesResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若上面开启的线程抛出AccessControlException异常，则返回StandardOutcomesResolver对象</span></span><br><span class="line">	<span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">		<span class="keyword">return</span> outcomesResolver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>createOutcomesResolver</code>方法创建了一个封装了<code>StandardOutcomesResolver</code>类的<code>ThreadedOutcomesResolver</code>解析对象。 我们再来看下<code>ThreadedOutcomesResolver</code>这个线程解析类封装<code>StandardOutcomesResolver</code>这个对象的目的是什么？我们继续跟进代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondtion.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadedOutcomesResolver</span><span class="params">(OutcomesResolver outcomesResolver)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里开启一个新的线程，这个线程其实还是利用StandardOutcomesResolver的resolveOutcomes方法</span></span><br><span class="line">	<span class="comment">// 对自动配置类进行解析判断是否匹配</span></span><br><span class="line">	<span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(</span><br><span class="line">			() -&gt; <span class="keyword">this</span>.outcomes = outcomesResolver.resolveOutcomes());</span><br><span class="line">	<span class="comment">// 开启线程</span></span><br><span class="line">	<span class="keyword">this</span>.thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在构造<code>ThreadedOutcomesResolver</code>对象时候，原来是开启了一个线程，然后这个线程其实还是调用了刚传进来的<code>StandardOutcomesResolver</code>对象的<code>resolveOutcomes</code>方法去解析自动配置类。具体如何解析呢？稍后我们在分析<code>【3】</code>处代码<code>secondHalfResolver.resolveOutcomes();</code>的时候再深究。</p>
<h4 id="new-StandardOutcomesResolver"><a href="#new-StandardOutcomesResolver" class="headerlink" title="new StandardOutcomesResolver"></a>new StandardOutcomesResolver</h4><p>这里对应前面5.1节的<code>【2】</code>处的代码<code>OutcomesResolver secondHalfResolver = new StandardOutcomesResolver(...);</code>，逻辑很简单，就是创建了一个<code>StandardOutcomesResolver</code>对象，用于后面解析自动配置类是否匹配，同时，新建的一个线程也是利用它来完成自动配置类的解析的。</p>
<h4 id="StandardOutcomesResolver-resolveOutcomes方法"><a href="#StandardOutcomesResolver-resolveOutcomes方法" class="headerlink" title="StandardOutcomesResolver.resolveOutcomes方法"></a>StandardOutcomesResolver.resolveOutcomes方法</h4><p>这里<code>StandardOutcomesResolver.resolveOutcomes</code>方法承担了解析自动配置类匹配与否的全部逻辑，是我们要重点分析的方法，<code>resolveOutcomes</code>方法最终把解析的自动配置类的结果赋给<code>secondHalf</code>数组。那么它是如何解析自动配置类是否匹配条件的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() &#123;</span><br><span class="line">	<span class="comment">// 再调用getOutcomes方法来解析</span></span><br><span class="line">	<span class="keyword">return</span> getOutcomes(<span class="keyword">this</span>.autoConfigurationClasses, <span class="keyword">this</span>.start, <span class="keyword">this</span>.end,</span><br><span class="line">			<span class="keyword">this</span>.autoConfigurationMetadata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,</span><br><span class="line">		<span class="keyword">int</span> start, <span class="keyword">int</span> end, AutoConfigurationMetadata autoConfigurationMetadata) &#123; <span class="comment">// 只要autoConfigurationMetadata没有存储相关自动配置类，那么outcome默认为null，则说明匹配</span></span><br><span class="line">	ConditionOutcome[] outcomes = <span class="keyword">new</span> ConditionOutcome[end - start];</span><br><span class="line">	<span class="comment">// 遍历每一个自动配置类</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">		String autoConfigurationClass = autoConfigurationClasses[i];</span><br><span class="line">		<span class="comment">// TODO 对于autoConfigurationMetadata有个疑问：为何有些自动配置类的条件注解能被加载到autoConfigurationMetadata，而有些又不能，比如自己定义的一个自动配置类HelloWorldEnableAutoConfiguration就没有被存到autoConfigurationMetadata中</span></span><br><span class="line">		<span class="keyword">if</span> (autoConfigurationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 这里取出注解在AutoConfiguration自动配置类类的@ConditionalOnClass注解的指定类的全限定名，</span></span><br><span class="line">			<span class="comment">// 举个栗子，看下面的KafkaStreamsAnnotationDrivenConfiguration这个自动配置类</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">@ConditionalOnClass</span>(StreamsBuilder.class)</span></span><br><span class="line"><span class="comment">			 * class KafkaStreamsAnnotationDrivenConfiguration &#123;</span></span><br><span class="line"><span class="comment">			 * // 省略无关代码</span></span><br><span class="line"><span class="comment">			 * &#125;</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// 那么取出的就是StreamsBuilder类的全限定名即candidates = org.apache.kafka.streams.StreamsBuilder</span></span><br><span class="line">			String candidates = autoConfigurationMetadata</span><br><span class="line">					.get(autoConfigurationClass, <span class="string">&quot;ConditionalOnClass&quot;</span>); <span class="comment">// 因为这里是处理某个类是否存在于classpath中，所以传入的key是ConditionalOnClass</span></span><br><span class="line">			<span class="comment">// 若自动配置类标有ConditionalOnClass注解且有值，此时调用getOutcome判断是否存在于类路径中</span></span><br><span class="line">			<span class="keyword">if</span> (candidates != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 拿到自动配置类注解@ConditionalOnClass的值后，再调用getOutcome方法去判断匹配结果,若该类存在于类路径，则getOutcome返回null，否则非null</span></span><br><span class="line">				<span class="comment">/*******************【主线，重点关注】******************/</span></span><br><span class="line">				outcomes[i - start] = getOutcome(candidates);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> outcomes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>StandardOutcomesResolver.resolveOutcomes</code>的方法中再次调用<code>getOutcomes</code>方法，主要是从<code>autoConfigurationMetadata</code>对象中获取到自动配置类上的注解<code>@ConditionalOnClass</code>指定的类的全限定名，然后作为参数传入<code>getOutcome</code>方法用于去类路径加载该类，若能加载到则说明注解<code>@ConditionalOnClass</code>满足条件，此时说明自动配置类匹配成功。</p>
<p>但是别忘了，这里只是过了<code>@ConditionalOnClass</code>注解这一关，若自动配置类还有其他注解比如<code>@ConditionalOnBean</code>，若该<code>@ConditionalOnBean</code>注解不满足条件的话，同样最终结果是不匹配的。这里扯的有点远，我们回到<code>OnClassCondtion</code>的判断逻辑，继续进入<code>getOutcome</code>方法看它是如何去判断<code>@ConditionalOnClass</code>注解满不满足条件的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的outcome记录的是不匹配的情况，不为null，则说明不匹配；为null，则说明匹配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String candidates)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// candidates的形式为“org.springframework.boot.autoconfigure.aop.AopAutoConfiguration.ConditionalOnClass=org.aspectj.lang.annotation.Aspect,org.aspectj.lang.reflect.Advice,org.aspectj.weaver.AnnotatedElement”</span></span><br><span class="line">	<span class="keyword">try</span> &#123;<span class="comment">// 自动配置类上@ConditionalOnClass的值只有一个的话，直接调用getOutcome方法判断是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> (!candidates.contains(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">			<span class="comment">// 看到因为传入的参数是 ClassNameFilter.MISSING，因此可以猜测这里应该是得到不匹配的结果</span></span><br><span class="line">			<span class="comment">/******************【主线，重点关注】********************/</span></span><br><span class="line">			<span class="keyword">return</span> getOutcome(candidates, ClassNameFilter.MISSING, </span><br><span class="line">					<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 自动配置类上@ConditionalOnClass的值有多个的话，则遍历每个值（其值以逗号，分隔）</span></span><br><span class="line">		<span class="keyword">for</span> (String candidate : StringUtils</span><br><span class="line">				.commaDelimitedListToStringArray(candidates)) &#123;</span><br><span class="line">			ConditionOutcome outcome = getOutcome(candidate,</span><br><span class="line">					ClassNameFilter.MISSING, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">			<span class="comment">// 可以看到，这里只要有一个不匹配的话，则返回不匹配结果</span></span><br><span class="line">			<span class="keyword">if</span> (outcome != <span class="keyword">null</span>) &#123; </span><br><span class="line">				<span class="keyword">return</span> outcome;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="comment">// We&#x27;ll get another chance later</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>getOutcome</code>方法再次调用重载方法<code>getOutcome</code>进一步去判断注解<code>@ConditionalOnClass</code>指定的类存不存在类路径中，跟着主线继续跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$StandardOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConditionOutcome <span class="title">getOutcome</span><span class="params">(String className,</span></span></span><br><span class="line"><span class="function"><span class="params">		ClassNameFilter classNameFilter, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 调用classNameFilter的matches方法来判断`@ConditionalOnClass`指定的类存不存在类路径中</span></span><br><span class="line">	<span class="comment">/******************【主线，重点关注】********************/</span></span><br><span class="line">	<span class="keyword">if</span> (classNameFilter.matches(className, classLoader)) &#123; <span class="comment">// 这里调用classNameFilter去判断className是否存在于类路径中，其中ClassNameFilter又分为PRESENT和MISSING两种;目前只看到ClassNameFilter为MISSING的调用情况，所以默认为true的话记录不匹配信息；若传入ClassNameFilter为PRESENT的话，估计还要再写一个else分支</span></span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome.noMatch(ConditionMessage</span><br><span class="line">				.forCondition(ConditionalOnClass.class)</span><br><span class="line">				.didNotFind(<span class="string">&quot;required class&quot;</span>).items(Style.QUOTE, className));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一层一层的剥，最终剥到了最底层了，这个真的需要足够耐心，没办法，源码只能一点一点的啃，嘿嘿。可以看到最终是调用<code>ClassNameFilter</code>的<code>matches</code>方法来判断<code>@ConditionalOnClass</code>指定的类存不存在类路径中,若不存在的话，则返回不匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilteringSpringBootCondition.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">enum</span> ClassNameFilter &#123;</span><br><span class="line">	<span class="comment">// 这里表示指定的类存在于类路径中，则返回true</span></span><br><span class="line">	PRESENT &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> isPresent(className, classLoader);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 这里表示指定的类不存在于类路径中，则返回true</span></span><br><span class="line">	MISSING &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> !isPresent(className, classLoader); <span class="comment">// 若classpath不存在className这个类，则返回true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 这又是一个抽象方法，分别被PRESENT和MISSING枚举类实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String className, ClassLoader classLoader)</span></span>;</span><br><span class="line">	<span class="comment">// 检查指定的类是否存在于类路径中	</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">(String className, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">			classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用类加载器去加载相应类，若没有抛出异常则说明类路径中存在该类，此时返回true</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			forName(className, classLoader); </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="comment">// 若不存在于类路径中，此时抛出的异常将catch住，返回false。</span></span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 利用类加载器去加载指定的类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className, ClassLoader classLoader)</span><br><span class="line">			<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> classLoader.loadClass(className);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Class.forName(className);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>ClassNameFilter</code>原来是<code>FilteringSpringBootCondition</code>的一个内部枚举类，其实现了判断指定类是否存在于<code>classpath</code>中的逻辑，这个类很简单，这里不再详述。</p>
<h4 id="ThreadedOutcomesResolver-resolveOutcomes方法"><a href="#ThreadedOutcomesResolver-resolveOutcomes方法" class="headerlink" title="ThreadedOutcomesResolver.resolveOutcomes方法"></a>ThreadedOutcomesResolver.resolveOutcomes方法</h4><p>这里是用新开启的线程去调用<code>StandardOutcomesResolver.resolveOutcomes</code>方法解析另一半自动配置类是否匹配，因为是新线程，这里很可能会出现这么一种情况：主线程解析完属于自己解析的一半自动配置类后，那么久继续往下跑了，此时不会等待新开启的子线程的。</p>
<p>因此，为了让主线程解析完后，我们需要让主线程继续等待正在解析的子线程，直到子线程结束。那么我们继续跟进代码区看下<code>ThreadedOutcomesResolver.resolveOutcomes</code>方法是怎样实现让主线程等待子线程的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnClassCondition$ThreadedOutcomesResolver.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ConditionOutcome[] resolveOutcomes() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 调用子线程的Join方法，让主线程等待</span></span><br><span class="line">		<span class="keyword">this</span>.thread.join();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">		Thread.currentThread().interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若子线程结束后，此时返回子线程的解析结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.outcomes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到用了<code>Thread.join()</code>方法来让主线程等待正在解析自动配置类的子线程，这里应该也可以用<code>CountDownLatch</code>来让主线程等待子线程结束。最终将子线程解析后的结果赋给<code>firstHalf</code>数组。</p>
<h3 id="AutoConfigurationImportListener"><a href="#AutoConfigurationImportListener" class="headerlink" title="AutoConfigurationImportListener"></a>AutoConfigurationImportListener</h3><p>这里继续深究前面节的 <code>AutoConfigurationImportSelector.getAutoConfigurationEntry</code>方法的触发自动配置类过滤完毕的事件<code>fireAutoConfigurationImportEvents(configurations, exclusions);</code>这句代码。</p>
<p>我们直接点进<code>fireAutoConfigurationImportEvents</code>方法看看其是如何触发事件的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireAutoConfigurationImportEvents</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">		Set&lt;String&gt; exclusions)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从spring.factories总获取到AutoConfigurationImportListener即ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line">	List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners(); </span><br><span class="line">	<span class="keyword">if</span> (!listeners.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">// 新建一个AutoConfigurationImportEvent事件</span></span><br><span class="line">		AutoConfigurationImportEvent event = <span class="keyword">new</span> AutoConfigurationImportEvent(<span class="keyword">this</span>,</span><br><span class="line">				configurations, exclusions);</span><br><span class="line">		<span class="comment">// 遍历刚获取到的AutoConfigurationImportListener</span></span><br><span class="line">		<span class="keyword">for</span> (AutoConfigurationImportListener listener : listeners) &#123;</span><br><span class="line">			<span class="comment">// 这里调用各种Aware方法用于触发事件前赋值，比如设置factory,environment等</span></span><br><span class="line">			invokeAwareMethods(listener);</span><br><span class="line">			<span class="comment">// 真正触发AutoConfigurationImportEvent事件即回调listener的onXXXEveent方法。这里用于记录自动配置类的评估信息</span></span><br><span class="line">			listener.onAutoConfigurationImportEvent(event); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，<code>fireAutoConfigurationImportEvents</code>方法做了以下两件事情：</p>
<ol>
<li>调用<code>getAutoConfigurationImportListeners</code>方法从<code>spring.factoris</code>配置文件获取实现<code>AutoConfigurationImportListener</code>接口的事件监听器；</li>
<li>遍历获取的各个事件监听器，然后调用监听器各种<code>Aware</code>方法给监听器赋值，最后再依次回调事件监听器的<code>onAutoConfigurationImportEvent</code>方法，执行监听事件的逻辑。</li>
</ol>
<p>此时我们再来看下<code>ConditionEvaluationReportAutoConfigurationImportListener</code>监听器监听到事件后，它的<code>onAutoConfigurationImportEvent</code>方法究竟做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConditionEvaluationReportAutoConfigurationImportListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAutoConfigurationImportEvent</span><span class="params">(AutoConfigurationImportEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 获取到条件评估报告器对象</span></span><br><span class="line">		ConditionEvaluationReport report = ConditionEvaluationReport</span><br><span class="line">				.get(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">		<span class="comment">// 将符合条件的自动配置类记录到unconditionalClasses集合中</span></span><br><span class="line">		report.recordEvaluationCandidates(event.getCandidateConfigurations());</span><br><span class="line">		<span class="comment">// 将要exclude的自动配置类记录到exclusions集合中</span></span><br><span class="line">		report.recordExclusions(event.getExclusions()); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>ConditionEvaluationReportAutoConfigurationImportListener</code>监听器监听到事件后，做的事情很简单，只是分别记录下符合条件和被<code>exclude</code>的自动配置类。</p>
<h2 id="AutoConfigurationPackages"><a href="#AutoConfigurationPackages" class="headerlink" title="AutoConfigurationPackages"></a>AutoConfigurationPackages</h2><p>前面已经详述了SpringBoot的自动配置原理了，最后的最后，跟SpringBoot自动配置有关的注解<code>@AutoConfigurationPackage</code>还没分析，我们来看下这个注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>@AutoConfigurationPackage</code>注解是跟SpringBoot自动配置所在的包相关的，即将 添加该注解的类所在的package 作为 自动配置package 进行管理。</p>
<p>接下来我们再看看<code>AutoConfigurationPackages.Registrar</code>类是干嘛的，直接看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AutoConfigurationPackages.Registrar.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    		BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    	register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Registrar</code>类是<code>AutoConfigurationPackages</code>的静态内部类，实现了<code>ImportBeanDefinitionRegistrar</code>和<code>DeterminableImports</code>两个接口。现在我们主要来关注下<code>Registrar</code>实现的<code>registerBeanDefinitions</code>方法,顾名思义，这个方法是注册<code>bean</code>定义的方法。看到它又调用了<code>AutoConfigurationPackages</code>的<code>register</code>方法，继续跟进源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AutoConfigurationPackages.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;</span><br><span class="line">		BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN);</span><br><span class="line">		ConstructorArgumentValues constructorArguments = beanDefinition</span><br><span class="line">				.getConstructorArgumentValues();</span><br><span class="line">		constructorArguments.addIndexedArgumentValue(<span class="number">0</span>,</span><br><span class="line">				addBasePackages(constructorArguments, packageNames));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">		beanDefinition.setBeanClass(BasePackages.class);</span><br><span class="line">		beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>,</span><br><span class="line">				packageNames);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(BEAN, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，可以看到<code>register</code>方法注册了一个<code>packageNames</code>即自动配置类注解<code>@EnableAutoConfiguration</code>所在的所在的包名相关的<code>bean</code>。那么注册这个<code>bean</code>的目的是为了什么呢？ 结合官网注释知道，注册这个自动配置包名相关的<code>bean</code>是为了被其他地方引用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，我们再总结下SpringBoot自动配置的原理，主要做了以下事情：</p>
<ol>
<li>从spring.factories配置文件中加载自动配置类；</li>
<li>加载的自动配置类中排除掉<code>@EnableAutoConfiguration</code>注解的<code>exclude</code>属性指定的自动配置类；</li>
<li>然后再用<code>AutoConfigurationImportFilter</code>接口去过滤自动配置类是否符合其标注注解（若有标注的话）<code>@ConditionalOnClass</code>,<code>@ConditionalOnBean</code>和<code>@ConditionalOnWebApplication</code>的条件，若都符合的话则返回匹配结果；</li>
<li>然后触发<code>AutoConfigurationImportEvent</code>事件，告诉<code>ConditionEvaluationReport</code>条件评估报告器对象来分别记录符合条件和<code>exclude</code>的自动配置类。</li>
<li>最后spring再将最后筛选后的自动配置类导入IOC容器中</li>
</ol>
<h1 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h1><blockquote>
<p>举个栗子：以配置web项目的服务器端口为例，若我们要将服务器端口配置为<code>8081</code>，那么我们会在<code>application.properties</code>配置文件中配置<code>server.port=8081</code>，此时该配置值<code>8081</code>就将会绑定到被<code>@ConfigurationProperties</code>注解的类<code>ServerProperties</code>的属性<code>port</code>上，从而使得配置生效。</p>
</blockquote>
<p>我们来看下<code>@ConfigurationProperties</code>这个注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 前缀别名</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;prefix&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 前缀</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 忽略无效的配置属性</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">ignoreInvalidFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 忽略未知的配置属性</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">ignoreUnknownFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ConfigurationProperties</code>这个注解的作用就是将外部配置的配置值绑定到其注解的类的属性上，可以作用于配置类或配置类的方法上。可以看到<code>@ConfigurationProperties</code>注解除了有设置前缀，是否忽略一些不存在或无效的配置等属性等外，这个注解没有其他任何的处理逻辑，可以看到<code>@ConfigurationProperties</code>是一个标志性的注解，<strong>源码入口不在这里</strong>。</p>
<p>同样，再来看下<code>@EnableConfigurationProperties</code>注解的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(EnableConfigurationPropertiesImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个值指定的类就是@ConfigurationProperties注解标注的类，其将会被注册到spring容器中</span></span><br><span class="line">	Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableConfigurationProperties</code>注解的主要作用就是为<code>@ConfigurationProperties</code>注解标注的类提供支持，即对将外部配置属性值（比如application.properties配置值）绑定到<code>@ConfigurationProperties</code>标注的类的属性中。</p>
<blockquote>
<p><strong>注意</strong>：SpringBoot源码中还存在了<code>ConfigurationPropertiesAutoConfiguration</code>这个自动配置类，同时<code>spring.factories</code>配置文件中的<code>EnableAutoConfiguration</code>接口也配置了<code>ConfigurationPropertiesAutoConfiguration</code>，这个自动配置类上也有<code>@EnableConfigurationProperties</code>这个注解，堆属性绑定进行了默认开启。</p>
</blockquote>
<p><strong>那么，<code>@EnableConfigurationProperties</code>这个注解对属性绑定提供怎样的支持呢？</strong></p>
<p>可以看到<code>@EnableConfigurationProperties</code>这个注解上还标注了<code>@Import(EnableConfigurationPropertiesImportSelector.class)</code>，其导入了<code>EnableConfigurationPropertiesImportSelector</code>，因此可以肯定的是<code>@EnableConfigurationProperties</code>这个注解对属性绑定提供的支持必定跟<code>EnableConfigurationPropertiesImportSelector</code>有关。</p>
<p>到了这里，<code>EnableConfigurationPropertiesImportSelector</code>这个注解是我们接下来要分析的对象，那么我们下面继续来分析<code>EnableConfigurationPropertiesImportSelector</code>是如何承担将外部配置属性值绑定到<code>@ConfigurationProperties</code>标注的类的属性中的。</p>
<h2 id="EnableConfigurationPropertiesImportSelector"><a href="#EnableConfigurationPropertiesImportSelector" class="headerlink" title="EnableConfigurationPropertiesImportSelector"></a>EnableConfigurationPropertiesImportSelector</h2><p><code>nableConfigurationPropertiesImportSelector</code>类的作用主要用来处理外部属性绑定的相关逻辑，其实现了<code>ImportSelector</code>接口，我们都知道，实现<code>ImportSelector</code>接口的<code>selectImports</code>方法可以向容器中注册bean。</p>
<p>那么，我们来看下<code>EnableConfigurationPropertiesImportSelector</code>覆写的<code>selectImports</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnableConfigurationPropertiesImportSelector.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnableConfigurationPropertiesImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IMPORTS数组即是要向spring容器中注册的bean</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] IMPORTS = &#123;</span><br><span class="line">			ConfigurationPropertiesBeanRegistrar.class.getName(),</span><br><span class="line">			ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">		<span class="comment">// 返回ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar的全限定名</span></span><br><span class="line">		<span class="comment">// 即上面两个类将会被注册到Spring容器中</span></span><br><span class="line">		<span class="keyword">return</span> IMPORTS;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>EnableConfigurationPropertiesImportSelector</code>类中的<code>selectImports</code>方法中返回的是<code>IMPORTS</code>数组，而这个<code>IMPORTS</code>是一个常量数组，值是<code>ConfigurationPropertiesBeanRegistrar</code>和<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>。即<code>EnableConfigurationPropertiesImportSelector</code>的作用是向Spring容器中注册了<code>ConfigurationPropertiesBeanRegistrar</code>和<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>这两个<code>bean</code>。</p>
<p>我们在<code>EnableConfigurationPropertiesImportSelector</code>类中没看到处理外部属性绑定的相关逻辑，其只是注册了<code>ConfigurationPropertiesBeanRegistrar</code>和<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>这两个<code>bean</code>,接下来我们再看下注册的这两个<code>bean</code>类。</p>
<h3 id="ConfigurationPropertiesBeanRegistrar"><a href="#ConfigurationPropertiesBeanRegistrar" class="headerlink" title="ConfigurationPropertiesBeanRegistrar"></a>ConfigurationPropertiesBeanRegistrar</h3><p><code>ConfigurationPropertiesBeanRegistrar</code>是<code>EnableConfigurationPropertiesImportSelector</code>的内部类，其实现了<code>ImportBeanDefinitionRegistrar</code>接口，覆写了<code>registerBeanDefinitions</code>方法。可见，<code>ConfigurationPropertiesBeanRegistrar</code>又是用来注册一些<code>bean</code> <code>definition</code>的，即也是向<code>Spring</code>容器中注册一些bean。</p>
<p>先看下<code>ConfigurationPropertiesBeanRegistrar</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBeanRegistrar$ConfigurationPropertiesBeanRegistrar.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesBeanRegistrar</span></span></span><br><span class="line"><span class="class">			<span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,  // metadata是AnnotationMetadataReadingVisitor对象，存储了某个配置类的元数据</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// （1）得到@EnableConfigurationProperties注解的所有属性值,</span></span><br><span class="line">		<span class="comment">// 比如@EnableConfigurationProperties(ServerProperties.class),那么得到的值是ServerProperties.class</span></span><br><span class="line">		<span class="comment">// （2）然后再将得到的@EnableConfigurationProperties注解的所有属性值注册到容器中</span></span><br><span class="line">		getTypes(metadata).forEach((type) -&gt; register(registry,</span><br><span class="line">				(ConfigurableListableBeanFactory) registry, type));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ConfigurationPropertiesBeanRegistrar</code>实现的<code>registerBeanDefinitions</code>中，可以看到主要做了两件事：</p>
<ol>
<li>调用<code>getTypes</code>方法获取<code>@EnableConfigurationProperties</code>注解的属性值<code>XxxProperties</code>；</li>
<li>调用<code>register</code>方法将获取的属性值<code>XxxProperties</code>注册到<code>Spring</code>容器中，用于以后和外部属性绑定时使用。</li>
</ol>
<p>我们来看下<code>getTypes</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBeanRegistrar$ConfigurationPropertiesBeanRegistrar.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; getTypes(AnnotationMetadata metadata) &#123;</span><br><span class="line">	<span class="comment">// 得到@EnableConfigurationProperties注解的所有属性值,</span></span><br><span class="line">	<span class="comment">// 比如@EnableConfigurationProperties(ServerProperties.class),那么得到的值是ServerProperties.class</span></span><br><span class="line">	MultiValueMap&lt;String, Object&gt; attributes = metadata</span><br><span class="line">			.getAllAnnotationAttributes(</span><br><span class="line">					EnableConfigurationProperties.class.getName(), <span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">// 将属性值取出装进List集合并返回</span></span><br><span class="line">	<span class="keyword">return</span> collectClasses((attributes != <span class="keyword">null</span>) ? attributes.get(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">			: Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getTypes</code>方法里面的逻辑很简单即将<code>@EnableConfigurationProperties</code>注解里面的属性值<code>XxxProperties</code>取出并装进<code>List</code>集合并返回。</p>
<p>由<code>getTypes</code>方法拿到<code>@EnableConfigurationProperties</code>注解里面的属性值<code>XxxProperties</code>（比如<code>ServerProperties.class</code>）后，此时再遍历将<code>XxxProperties</code>逐个注册进<code>Spring</code>容器中，我们来看下<code>register</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBeanRegistrar$ConfigurationPropertiesBeanRegistrar.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">		ConfigurableListableBeanFactory beanFactory, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 得到type的名字，一般用类的全限定名作为bean name</span></span><br><span class="line">	String name = getName(type);</span><br><span class="line">	<span class="comment">// 根据bean name判断beanFactory容器中是否包含该bean</span></span><br><span class="line">	<span class="keyword">if</span> (!containsBeanDefinition(beanFactory, name)) &#123;</span><br><span class="line">		<span class="comment">// 若不包含，那么注册bean definition</span></span><br><span class="line">		registerBeanDefinition(registry, name, type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们再来看下由<code>EnableConfigurationPropertiesImportSelector</code>导入的另一个类<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>又是干嘛的呢？</p>
<h3 id="ConfigurationPropertiesBindingPostProcessorRegistrar"><a href="#ConfigurationPropertiesBindingPostProcessorRegistrar" class="headerlink" title="ConfigurationPropertiesBindingPostProcessorRegistrar"></a>ConfigurationPropertiesBindingPostProcessorRegistrar</h3><p>可以看到<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>类名字又是以<code>Registrar</code>单词为结尾，说明其肯定又是导入一些<code>bean</code> <code>definition</code>的。直接看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessorRegistrar.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesBindingPostProcessorRegistrar</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 若容器中没有注册ConfigurationPropertiesBindingPostProcessor这个处理属性绑定的后置处理器，</span></span><br><span class="line">		<span class="comment">// 那么将注册ConfigurationPropertiesBindingPostProcessor和ConfigurationBeanFactoryMetadata这两个bean</span></span><br><span class="line">		<span class="comment">// 注意onApplicationEnvironmentPreparedEvent事件加载配置属性在先，然后再注册一些后置处理器用来处理这些配置属性</span></span><br><span class="line">		<span class="keyword">if</span> (!registry.containsBeanDefinition(</span><br><span class="line">				ConfigurationPropertiesBindingPostProcessor.BEAN_NAME)) &#123;</span><br><span class="line">			<span class="comment">// (1)注册ConfigurationPropertiesBindingPostProcessor后置处理器，用来对配置属性进行后置处理</span></span><br><span class="line">			registerConfigurationPropertiesBindingPostProcessor(registry);</span><br><span class="line">			<span class="comment">// (2)注册一个ConfigurationBeanFactoryMetadata类型的bean，</span></span><br><span class="line">			<span class="comment">// 注意ConfigurationBeanFactoryMetadata实现了BeanFactoryPostProcessor，然后其会在postProcessBeanFactory中注册一些元数据</span></span><br><span class="line">			registerConfigurationBeanFactoryMetadata(registry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册ConfigurationPropertiesBindingPostProcessor后置处理器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerConfigurationPropertiesBindingPostProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		GenericBeanDefinition definition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">		definition.setBeanClass(ConfigurationPropertiesBindingPostProcessor.class);</span><br><span class="line">		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(</span><br><span class="line">				ConfigurationPropertiesBindingPostProcessor.BEAN_NAME, definition);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册ConfigurationBeanFactoryMetadata后置处理器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerConfigurationBeanFactoryMetadata</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		GenericBeanDefinition definition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">		definition.setBeanClass(ConfigurationBeanFactoryMetadata.class);</span><br><span class="line">		definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(ConfigurationBeanFactoryMetadata.BEAN_NAME,</span><br><span class="line">				definition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>类的逻辑非常简单，主要用来注册外部配置属性绑定相关的后置处理器即<code>ConfigurationBeanFactoryMetadata</code>和<code>ConfigurationPropertiesBindingPostProcessor</code>。</p>
<p>那么接下来我们再来探究下注册的这两个后置处理器又是执行怎样的后置处理逻辑呢？</p>
<h3 id="ConfigurationBeanFactoryMetadata"><a href="#ConfigurationBeanFactoryMetadata" class="headerlink" title="ConfigurationBeanFactoryMetadata"></a>ConfigurationBeanFactoryMetadata</h3><p>先来看<code>ConfigurationBeanFactoryMetadata</code>这个后置处理器，其实现了<code>BeanFactoryPostProcessor</code>接口的<code>postProcessBeanFactory</code>方法，在初始化<code>bean</code> <code>factory</code>时将<code>@Bean</code>注解的元数据存储起来，以便在后续的外部配置属性绑定的相关逻辑中使用。</p>
<p>先来看下<code>ConfigurationBeanFactoryMetadata</code>类实现<code>BeanFactoryPostProcessor</code>接口的<code>postProcessBeanFactory</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationBeanFactoryMetadata</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationBeanFactoryMetadata</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The bean name that this class is registered with.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = ConfigurationBeanFactoryMetadata.class</span><br><span class="line">			.getName();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * beansFactoryMetadata集合存储beansFactory的元数据</span></span><br><span class="line"><span class="comment">	 * key:某个bean的名字  value：FactoryMetadata对象（封装了工厂bean名和工厂方法名）</span></span><br><span class="line"><span class="comment">	 * 比如下面这个配置类：</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Configuration</span></span></span><br><span class="line"><span class="comment">	 * public class ConfigA &#123;</span></span><br><span class="line"><span class="comment">	 *      <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">	 *      public BeanXXX methodB（configA, ） &#123;</span></span><br><span class="line"><span class="comment">	 *          return new BeanXXX();</span></span><br><span class="line"><span class="comment">	 *      &#125;</span></span><br><span class="line"><span class="comment">	 * &#125;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 那么：key值为&quot;methodB&quot;，value为FactoryMetadata（configA, methodB）对象，其bean属性值为&quot;configA&quot;,method属性值为&quot;methodB&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, FactoryMetadata&gt; beansFactoryMetadata = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		<span class="comment">// 遍历beanFactory的beanDefinitionName，即每个bean的名字（比如工厂方法对应的bean名字）</span></span><br><span class="line">		<span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">			<span class="comment">// 根据name得到beanDefinition</span></span><br><span class="line">			BeanDefinition definition = beanFactory.getBeanDefinition(name);</span><br><span class="line">			<span class="comment">// 工厂方法名：一般是注解@Bean的方法名</span></span><br><span class="line">			String method = definition.getFactoryMethodName();</span><br><span class="line">			<span class="comment">// 工厂bean名：一般是注解@Configuration的类名</span></span><br><span class="line">			String bean = definition.getFactoryBeanName();</span><br><span class="line">			<span class="keyword">if</span> (method != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 将beanDefinitionName作为Key，封装了工厂bean名和工厂方法名的FactoryMetadata对象作为value装入beansFactoryMetadata中</span></span><br><span class="line">				<span class="keyword">this</span>.beansFactoryMetadata.put(name, <span class="keyword">new</span> FactoryMetadata(bean, method));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看到<code>ConfigurationBeanFactoryMetadata</code>类覆写的<code>postProcessBeanFactory</code>方法做的事情就是将工厂<code>Bean</code>（可以理解为<code>@Configuration</code>注解的类）及其<code>@Bean</code>注解的工厂方法的一些元数据缓存到<code>beansFactoryMetadata</code>集合中，以便后续使用，这个后面会详述。</p>
<p>由上代码中我们看到了<code>ConfigurationBeanFactoryMetadata</code>类的<code>beansFactoryMetadata</code>集合类型是<code>Map&lt;String, FactoryMetadata&gt;</code>，那么我们再来看下封装相关工厂元数据的<code>FactoryMetadata</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationBeanFactoryMetadata$FactoryMetadata.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMetadata</span> </span>&#123;</span><br><span class="line">	<span class="comment">// @Configuration注解的配置类的类名</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String bean;</span><br><span class="line">	<span class="comment">// @Bean注解的方法名</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String method;</span><br><span class="line"></span><br><span class="line">	FactoryMetadata(String bean, String method) &#123;</span><br><span class="line">		<span class="keyword">this</span>.bean = bean;</span><br><span class="line">		<span class="keyword">this</span>.method = method;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FactoryMetadata</code>仅有两个属性<code>bean</code>和<code>method</code>,分别表示<code>@Configuration</code>注解的工厂<code>bean</code>和<code>@Bean</code>注解的工厂方法。</p>
<p>上面说了那么多，直接举个栗子会更直观：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * beansFactoryMetadata集合存储beansFactory的元数据</span></span><br><span class="line"><span class="comment"> * key:某个bean的名字  value：FactoryMetadata对象（封装了工厂bean名和工厂方法名）</span></span><br><span class="line"><span class="comment"> * 比如下面这个配置类：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span></span></span><br><span class="line"><span class="comment"> * public class ConfigA &#123;</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> *      public BeanXXX methodB（configA, ） &#123;</span></span><br><span class="line"><span class="comment"> *          return new BeanXXX();</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 那么：key值为&quot;methodB&quot;，value为FactoryMetadata（configA, methodB）对象，其bean属性值为&quot;configA&quot;,method属性值为&quot;methodB&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, FactoryMetadata&gt; beansFactoryMetadata = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了更好理解上面<code>beansFactoryMetadata</code>集合存储的数据是啥，建议最好自己动手调试看看其里面装的是什么哦。总之这里记住一点就好了：<code>ConfigurationBeanFactoryMetadata</code>类的<code>beansFactoryMetadata</code>集合存储的是工厂<code>bean</code>的相关元数据，以便在<code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器中使用。</p>
<h3 id="ConfigurationPropertiesBindingPostProcessor"><a href="#ConfigurationPropertiesBindingPostProcessor" class="headerlink" title="ConfigurationPropertiesBindingPostProcessor"></a>ConfigurationPropertiesBindingPostProcessor</h3><p>我们再来看下<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>类注册的另外一个后置处理器<code>ConfigurationPropertiesBindingPostProcessor</code>，这个后置处理器就<strong>尤其重要</strong>了，主要承担了<strong>将外部配置属性绑定到<code>@ConfigurationProperties</code>注解标注的XxxProperties类的属性中</strong>（比如<code>application.properties</code>配置文件中设置了<code>server.port=8081</code>,那么<code>8081</code>将会绑定到<code>ServerProperties</code>类的<code>port</code>属性中）的实现逻辑。</p>
<p>同样，先来看下<code>ConfigurationPropertiesBindingPostProcessor</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesBindingPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>,</span></span><br><span class="line"><span class="class">	<span class="title">PriorityOrdered</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	    <span class="comment">// ...这里省略实现代码先</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// ...这里省略实现代码先</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...省略非关键代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器实现了两个重要的接口<code>InitializingBean</code>和<code>BeanPostProcessor</code>。</p>
<blockquote>
<p><code>InitializingBean</code>接口的<code>afterPropertiesSet</code>方法会在<code>bean</code>属性赋值后调用，用来执行一些自定义的初始化逻辑比如检查某些强制的属性是否有被赋值，校验某些配置或给一些未被赋值的属性赋值。</p>
<p><code>BeanPostProcessor</code>接口是<code>bean</code>的后置处理器，其有<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>两个勾子方法，分别会在<code>bean</code>初始化前后被调用来执行一些后置处理逻辑，比如检查标记接口或是否用代理包装了<code>bean</code>。</p>
</blockquote>
<p>同时由上代码可以看到<code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器覆写了<code>InitializingBean</code>的<code>afterPropertiesSet</code>方法和<code>BeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法。</p>
<p>接下来我们再来探究<code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器覆写的两个方法的源码。</p>
<h3 id="在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器"><a href="#在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器" class="headerlink" title="在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器"></a>在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器</h3><p>我们先来分析下<code>ConfigurationPropertiesBindingPostProcessor</code>覆写<code>InitializingBean</code>接口的<code>afterPropertiesSet</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessor.java</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 配置属性校验器名字</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALIDATOR_BEAN_NAME = <span class="string">&quot;configurationPropertiesValidator&quot;</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 工厂bean相关元数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ConfigurationBeanFactoryMetadata beanFactoryMetadata;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 上下文</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 配置属性绑定器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ConfigurationPropertiesBinder configurationPropertiesBinder;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里主要是给beanFactoryMetadata和configurationPropertiesBinder的属性赋值，用于后面的后置处理器方法处理属性绑定的时候用</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// We can&#x27;t use constructor injection of the application context because</span></span><br><span class="line">		<span class="comment">// it causes eager factory bean initialization</span></span><br><span class="line">		<span class="comment">// 【1】利用afterPropertiesSet这个勾子方法从容器中获取之前注册的ConfigurationBeanFactoryMetadata对象赋给beanFactoryMetadata属性</span></span><br><span class="line">		<span class="comment">// （问1）beanFactoryMetadata这个bean是什么时候注册到容器中的？</span></span><br><span class="line">		<span class="comment">// （答1）在ConfigurationPropertiesBindingPostProcessorRegistrar类的registerBeanDefinitions方法中将beanFactoryMetadata这个bean注册到容器中</span></span><br><span class="line">		<span class="comment">// （问2）从容器中获取beanFactoryMetadata对象后，什么时候会被用到？</span></span><br><span class="line">		<span class="comment">// （答2）beanFactoryMetadata对象的beansFactoryMetadata集合保存的工厂bean相关的元数据，在ConfigurationPropertiesBindingPostProcessor类</span></span><br><span class="line">		<span class="comment">//        要判断某个bean是否有FactoryAnnotation或FactoryMethod时会根据这个beanFactoryMetadata对象的beansFactoryMetadata集合的元数据来查找</span></span><br><span class="line">		<span class="keyword">this</span>.beanFactoryMetadata = <span class="keyword">this</span>.applicationContext.getBean(</span><br><span class="line">				ConfigurationBeanFactoryMetadata.BEAN_NAME,</span><br><span class="line">				ConfigurationBeanFactoryMetadata.class);</span><br><span class="line">		<span class="comment">// 【2】new一个ConfigurationPropertiesBinder，用于后面的外部属性绑定时使用</span></span><br><span class="line">		<span class="keyword">this</span>.configurationPropertiesBinder = <span class="keyword">new</span> ConfigurationPropertiesBinder(</span><br><span class="line">				<span class="keyword">this</span>.applicationContext, VALIDATOR_BEAN_NAME); <span class="comment">// VALIDATOR_BEAN_NAME=&quot;configurationPropertiesValidator&quot;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到以上代码主要逻辑就是<strong>在执行外部属性绑定逻辑前先准备好相关元数据和配置属性绑定器</strong>，即从<code>Spring</code>容器中获取到之前注册的<code>ConfigurationBeanFactoryMetadata</code>对象赋给<code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器的<code>beanFactoryMetadata</code>属性,还有就是新建一个<code>ConfigurationPropertiesBinder</code>配置属性绑定器对象并赋值给<code>configurationPropertiesBinder</code>属性。</p>
<p>我们再来看下<code>ConfigurationPropertiesBinder</code>这个配置属性绑定器对象是如何构造的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBinder.java</span></span><br><span class="line"></span><br><span class="line">ConfigurationPropertiesBinder(ApplicationContext applicationContext,</span><br><span class="line">		String validatorBeanName) &#123;</span><br><span class="line">	<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	<span class="comment">// 将applicationContext封装到PropertySourcesDeducer对象中并返回</span></span><br><span class="line">	<span class="keyword">this</span>.propertySources = <span class="keyword">new</span> PropertySourcesDeducer(applicationContext)</span><br><span class="line">			.getPropertySources(); <span class="comment">// 获取属性源，主要用于在ConfigurableListableBeanFactory的后置处理方法postProcessBeanFactory中处理</span></span><br><span class="line">	<span class="comment">// 如果没有配置validator的话，这里一般返回的是null</span></span><br><span class="line">	<span class="keyword">this</span>.configurationPropertiesValidator = getConfigurationPropertiesValidator(</span><br><span class="line">			applicationContext, validatorBeanName);</span><br><span class="line">	<span class="comment">// 检查实现JSR-303规范的bean校验器相关类在classpath中是否存在</span></span><br><span class="line">	<span class="keyword">this</span>.jsr303Present = ConfigurationPropertiesJsr303Validator</span><br><span class="line">			.isJsr303Present(applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在构造<code>ConfigurationPropertiesBinder</code>对象时主要给其相关属性赋值（一般构造器逻辑都是这样）：</p>
<ol>
<li>给<code>applicationContext</code>属性赋值注入上下文对象；</li>
<li>给<code>propertySources</code>属性赋值，属性源即外部配置值比如<code>application.properties</code>配置的属性值，注意这里的属性源是由<code>ConfigFileApplicationListener</code>这个监听器负责读取的，<code>ConfigFileApplicationListener</code>将会在后面源码分析章节中详述。</li>
<li>给<code>configurationPropertiesValidator</code>属性赋值，值来自<code>Spring</code>容器中名为<code>configurationPropertiesValidator</code>的<code>bean</code>。</li>
<li>给<code>jsr303Present</code>属性赋值，当<code>javax.validation.Validator</code>,<code>javax.validation.ValidatorFactory</code>和<code>javax.validation.bootstrap.GenericBootstrap&quot;</code>这三个类同时存在于<code>classpath</code>中<code>jsr303Present</code>属性值才为<code>true</code>。</li>
</ol>
<blockquote>
<p><strong>关于JSR303</strong>：<code>JSR-303</code>是JAVA EE 6中的一项子规范，叫做<code>Bean Validation</code>，<code>Hibernate Validator</code>是<code>Bean Validation</code>的参考实现 。<code>Hibernate Validator</code>提供了<code>JSR 303</code>规范中所有内置<code>constraint</code> 的实现，除此之外还有一些附加的<code>constraint</code>。</p>
</blockquote>
<h2 id="执行真正的外部属性绑定逻辑"><a href="#执行真正的外部属性绑定逻辑" class="headerlink" title="执行真正的外部属性绑定逻辑"></a>执行真正的外部属性绑定逻辑</h2><p>前面分析了那么多，发现都还没到外部属性绑定的真正处理逻辑，前面步骤都是在做一些准备性工作，为外部属性绑定做铺垫。</p>
<p>在执行外部属性绑定逻辑前，准备好了相关元数据和配置属性绑定器后，此时我们再来看看<code>ConfigurationPropertiesBindingPostProcessor</code>实现<code>BeanPostProcessor</code>接口的<code>postProcessBeforeInitialization</code>后置处理方法了，<strong>外部属性绑定逻辑</strong>都是在这个后置处理方法里实现，是我们关注的<strong>重中之重</strong>。</p>
<p>直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是外部配置属性后置处理器，因此这里对@ConfigurationProperties注解标注的XxxProperties类进行后置处理完成属性绑定</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">// 注意，BeanPostProcessor后置处理器默认会对所有的bean进行处理，因此需要根据bean的一些条件进行过滤得到最终要处理的目的bean，</span></span><br><span class="line">	<span class="comment">// 这里的过滤条件就是判断某个bean是否有@ConfigurationProperties注解</span></span><br><span class="line">	<span class="comment">// 【1】从bean上获取@ConfigurationProperties注解,若bean有标注，那么返回该注解；若没有，则返回Null。比如ServerProperty上标注了@ConfigurationProperties注解</span></span><br><span class="line">	ConfigurationProperties annotation = getAnnotation(bean, beanName,</span><br><span class="line">			ConfigurationProperties.class);</span><br><span class="line">	<span class="comment">// 【2】若标注有@ConfigurationProperties注解的bean，那么则进行进一步处理：将配置文件的配置注入到bean的属性值中</span></span><br><span class="line">	<span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/********主线，重点关注】********/</span></span><br><span class="line">		bind(bean, beanName, annotation); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 【3】返回外部配置属性值绑定后的bean（一般是XxxProperties对象）</span></span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConfigurationPropertiesBindingPostProcessor</code>类覆写的<code>postProcessBeforeInitialization</code>方法的做的事情就是将外部属性配置绑定到<code>@ConfigurationProperties</code>注解标注的<code>XxxProperties</code>类上，现关键步骤总结如下：</p>
<ol>
<li>从<code>bean</code>上获取<code>@ConfigurationProperties</code>注解；</li>
<li>若标注有<code>@ConfigurationProperties</code>注解的<code>bean</code>，那么则进行进一步的处理：将外部配置属性值绑定到bean的属性值中后再返回<code>bean</code>；若没有标注有<code>@ConfigurationProperties</code>注解的<code>bean</code>，那么将直接原样返回<code>bean</code>。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：后置处理器默认会对每个容器中的<code>bean</code>进行后置处理，因为这里只针对标注有<code>@ConfigurationProperties</code>注解的<code>bean</code>进行外部属性绑定，因此没有标注<code>@ConfigurationProperties</code>注解的<code>bean</code>将不会被处理。</p>
</blockquote>
<p>接下来我们紧跟主线，再来看下<strong>外部配置属性是如何绑定到<code>@ConfigurationProperties</code>注解的<code>XxxProperties</code>类属性上的呢？</strong></p>
<p>直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object bean, String beanName, ConfigurationProperties annotation)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 【1】得到bean的类型，比如ServerPropertie这个bean得到的类型是：org.springframework.boot.autoconfigure.web.ServerProperties</span></span><br><span class="line">	ResolvableType type = getBeanType(bean, beanName);</span><br><span class="line">	<span class="comment">// 【2】获取bean上标注的@Validated注解</span></span><br><span class="line">	Validated validated = getAnnotation(bean, beanName, Validated.class);</span><br><span class="line">	<span class="comment">// 若标注有@Validated注解的话则跟@ConfigurationProperties注解一起组成一个Annotation数组</span></span><br><span class="line">	Annotation[] annotations = (validated != <span class="keyword">null</span>)</span><br><span class="line">			? <span class="keyword">new</span> Annotation[] &#123; annotation, validated &#125;</span><br><span class="line">			: <span class="keyword">new</span> Annotation[] &#123; annotation &#125;;</span><br><span class="line">	<span class="comment">// 【3】返回一个绑定了XxxProperties类的Bindable对象target，这个target对象即被外部属性值注入的目标对象</span></span><br><span class="line">	<span class="comment">// （比如封装了标注有@ConfigurationProperties注解的ServerProperties对象的Bindable对象）</span></span><br><span class="line">	Bindable&lt;?&gt; target = Bindable.of(type).withExistingValue(bean)</span><br><span class="line">			.withAnnotations(annotations); <span class="comment">// 设置annotations属性数组</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 【4】执行外部配置属性绑定逻辑</span></span><br><span class="line">		<span class="comment">/********【主线，重点关注】********/</span></span><br><span class="line">		<span class="keyword">this</span>.configurationPropertiesBinder.bind(target);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationPropertiesBindException(beanName, bean, annotation,</span><br><span class="line">				ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键步骤上面代码已经标注<code>【x】</code>，这里在继续讲解外部配置属性绑定的主线逻辑(在8 ConfigurationPropertiesBinder这一小节分析 )前先穿插一个知识点，还记得<code>ConfigurationBeanFactoryMetadata</code>覆写的<code>postProcessBeanFactory</code>方法里已经将相关工厂<code>bean</code>的元数据封装到<code>ConfigurationBeanFactoryMetadata</code>类的<code>beansFactoryMetadata</code>集合这一回事吗？</p>
<p>我们再来看下上面代码中的<code>【1】getBeanType</code>和<code>【2】getAnnotation</code>方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBindingPostProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResolvableType <span class="title">getBeanType</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 首先获取有没有工厂方法</span></span><br><span class="line">	Method factoryMethod = <span class="keyword">this</span>.beanFactoryMetadata.findFactoryMethod(beanName);</span><br><span class="line">	<span class="comment">// 若有工厂方法</span></span><br><span class="line">	<span class="keyword">if</span> (factoryMethod != <span class="keyword">null</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> ResolvableType.forMethodReturnType(factoryMethod);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">// 没有工厂方法，则说明是普通的配置类</span></span><br><span class="line">	<span class="keyword">return</span> ResolvableType.forClass(bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Object bean, String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;A&gt; type)</span> </span>&#123;</span><br><span class="line">	A annotation = <span class="keyword">this</span>.beanFactoryMetadata.findFactoryAnnotation(beanName, type);</span><br><span class="line">	<span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">		annotation = AnnotationUtils.findAnnotation(bean.getClass(), type);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> annotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面代码中的<code>beanFactoryMetadata</code>对象没，<code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器的<code>getBeanType</code>和<code>getAnnotation</code>方法分别会调用<code>ConfigurationBeanFactoryMetadata</code>的<code>findFactoryMethod</code>和<code>findFactoryAnnotation</code>方法，而<code>ConfigurationBeanFactoryMetadata</code>的<code>findFactoryMethod</code>和<code>findFactoryAnnotation</code>方法又会依赖存储工厂<code>bean</code>元数据的<code>beansFactoryMetadata</code>集合来寻找是否有<code>FactoryMethod</code>和<code>FactoryAnnotation</code>。因此，到这里我们就知道之<code>ConfigurationBeanFactoryMetadata</code>的<code>beansFactoryMetadata</code>集合存储工厂<code>bean</code>元数据的作用了。</p>
<h3 id="ConfigurationPropertiesBinder"><a href="#ConfigurationPropertiesBinder" class="headerlink" title="ConfigurationPropertiesBinder"></a>ConfigurationPropertiesBinder</h3><p>我们再继续紧跟外部配置属性绑定的主线，继续前面看执行真正的外部属性绑定逻辑中的<code>this.configurationPropertiesBinder.bind(target);</code>这句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBinder.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Bindable&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//【1】得到@ConfigurationProperties注解</span></span><br><span class="line">	ConfigurationProperties annotation = target</span><br><span class="line">			.getAnnotation(ConfigurationProperties.class);</span><br><span class="line">	Assert.state(annotation != <span class="keyword">null</span>,</span><br><span class="line">			() -&gt; <span class="string">&quot;Missing @ConfigurationProperties on &quot;</span> + target);</span><br><span class="line">	<span class="comment">// 【2】得到Validator对象集合，用于属性校验</span></span><br><span class="line">	List&lt;Validator&gt; validators = getValidators(target);</span><br><span class="line">	<span class="comment">// 【3】得到BindHandler对象（默认是IgnoreTopLevelConverterNotFoundBindHandler对象），</span></span><br><span class="line">	<span class="comment">// 用于对ConfigurationProperties注解的ignoreUnknownFields等属性的处理</span></span><br><span class="line">	BindHandler bindHandler = getBindHandler(annotation, validators);</span><br><span class="line">	<span class="comment">// 【4】得到一个Binder对象，并利用其bind方法执行外部属性绑定逻辑</span></span><br><span class="line">	<span class="comment">/********************【主线，重点关注】********************/</span></span><br><span class="line">	getBinder().bind(annotation.prefix(), target, bindHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的主要逻辑是：</p>
<ol>
<li>先获取<code>target</code>对象（对应<code>XxxProperties</code>类）上的<code>@ConfigurationProperties</code>注解和校验器（若有）;</li>
<li>然后再根据获取的的<code>@ConfigurationProperties</code>注解和校验器来获得<code>BindHandler</code>对象，<code>BindHandler</code>的作用是用于在属性绑定时来处理一些附件逻辑</li>
<li>最后再获取一个<code>Binder</code>对象，调用其<code>bind</code>方法来执行外部属性绑定的逻辑</li>
</ol>
<h3 id="获取BindHandler对象以便在属性绑定时来处理一些附件逻辑"><a href="#获取BindHandler对象以便在属性绑定时来处理一些附件逻辑" class="headerlink" title="获取BindHandler对象以便在属性绑定时来处理一些附件逻辑"></a>获取BindHandler对象以便在属性绑定时来处理一些附件逻辑</h3><p>我们在看<code>getBindHandler</code>方法的逻辑前先来认识下<code>BindHandler</code>是干啥的。</p>
<p><code>BindHandler</code>是一个父类接口，用于在属性绑定时来处理一些附件逻辑。我们先看下<code>BindHandler</code>的类图，好有一个整体的认识：</p>
<p><img src="/blogImg/BindHandler%E7%B1%BB%E5%9B%BE.png" alt="BindHandler类图"></p>
<p>可以看到<code>AbstractBindHandler</code>作为抽象基类实现了<code>BindHandler</code>接口，其又有四个具体的子类分别是<code>IgnoreTopLevelConverterNotFoundBindHandler</code>,<code>NoUnboundElementsBindHandler</code>,<code>IgnoreErrorsBindHandler</code>和<code>ValidationBindHandler</code>。</p>
<ol>
<li><code>IgnoreTopLevelConverterNotFoundBindHandler</code>：在处理外部属性绑定时的默认<code>BindHandler</code>，当属性绑定失败时会忽略最顶层的<code>ConverterNotFoundException</code>；</li>
<li><code>NoUnboundElementsBindHandler</code>：用来处理配置文件配置的未知的属性；</li>
<li><code>IgnoreErrorsBindHandler</code>：用来忽略无效的配置属性例如类型错误；</li>
<li><code>ValidationBindHandler</code>：利用校验器对绑定的结果值进行校验。</li>
</ol>
<p>分析完类关系后，我们再来看下<code>BindHandler</code>接口提供了哪些方法在外部属性绑定时提供一些额外的附件逻辑，直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BindHandler.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BindHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Default no-op bind handler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BindHandler DEFAULT = <span class="keyword">new</span> BindHandler() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// onStart方法在外部属性绑定前被调用</span></span><br><span class="line">	<span class="keyword">default</span> &lt;T&gt; <span class="function">Bindable&lt;T&gt; <span class="title">onStart</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">			BindContext context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// onSuccess方法在外部属性成功绑定时被调用，该方法能够改变最终返回的属性值或对属性值进行校验</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">onSuccess</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">			BindContext context, Object result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// onFailure方法在外部属性绑定失败（包括onSuccess方法里的逻辑执行失败）时被调用，</span></span><br><span class="line">	<span class="comment">// 该方法可以用来catch住相关异常或者返回一个替代的结果（跟微服务的降级结果有点类似，嘿嘿）</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">onFailure</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">			BindContext context, Exception error)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当外部属性绑定结束时（不管绑定成功还是失败）被调用</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">			BindContext context, Object result)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>BindHandler</code>接口定义了<code>onStart</code>,<code>onSuccess</code>,<code>onFailure</code>和<code>onFinish</code>方法，这四个方法分别会在执行外部属性绑定时的不同时机会被调用，在属性绑定时用来添加一些额外的处理逻辑，比如在<code>onSuccess</code>方法改变最终绑定的属性值或对属性值进行校验，在<code>onFailure</code>方法<code>catch</code>住相关异常或者返回一个替代的绑定的属性值。</p>
<p>知道了<code>BindHandler</code>是在属性绑定时添加一些额外的附件处理逻辑后，我们再来看下<code>getBindHandler</code>方法的逻辑，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBinder.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意BindHandler的设计技巧，应该是责任链模式，非常巧妙，值得借鉴</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BindHandler <span class="title">getBindHandler</span><span class="params">(ConfigurationProperties annotation,</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;Validator&gt; validators)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 新建一个IgnoreTopLevelConverterNotFoundBindHandler对象，这是个默认的BindHandler对象</span></span><br><span class="line">	BindHandler handler = <span class="keyword">new</span> IgnoreTopLevelConverterNotFoundBindHandler();</span><br><span class="line">	<span class="comment">// 若注解@ConfigurationProperties的ignoreInvalidFields属性设置为true，</span></span><br><span class="line">	<span class="comment">// 则说明可以忽略无效的配置属性例如类型错误，此时新建一个IgnoreErrorsBindHandler对象</span></span><br><span class="line">	<span class="keyword">if</span> (annotation.ignoreInvalidFields()) &#123;</span><br><span class="line">		handler = <span class="keyword">new</span> IgnoreErrorsBindHandler(handler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若注解@ConfigurationProperties的ignoreUnknownFields属性设置为true，</span></span><br><span class="line">	<span class="comment">// 则说明配置文件配置了一些未知的属性配置，此时新建一个ignoreUnknownFields对象</span></span><br><span class="line">	<span class="keyword">if</span> (!annotation.ignoreUnknownFields()) &#123;</span><br><span class="line">		UnboundElementsSourceFilter filter = <span class="keyword">new</span> UnboundElementsSourceFilter();</span><br><span class="line">		handler = <span class="keyword">new</span> NoUnboundElementsBindHandler(handler, filter);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果@Valid注解不为空，则创建一个ValidationBindHandler对象</span></span><br><span class="line">	<span class="keyword">if</span> (!validators.isEmpty()) &#123;</span><br><span class="line">		handler = <span class="keyword">new</span> ValidationBindHandler(handler,</span><br><span class="line">				validators.toArray(<span class="keyword">new</span> Validator[<span class="number">0</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历获取的ConfigurationPropertiesBindHandlerAdvisor集合，</span></span><br><span class="line">	<span class="comment">// ConfigurationPropertiesBindHandlerAdvisor目前只在测试类中有用到</span></span><br><span class="line">	<span class="keyword">for</span> (ConfigurationPropertiesBindHandlerAdvisor advisor : getBindHandlerAdvisors()) &#123;</span><br><span class="line">		<span class="comment">// 对handler进一步处理</span></span><br><span class="line">		handler = advisor.apply(handler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回handler</span></span><br><span class="line">	<span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getBindHandler</code>方法的逻辑很简单，主要是根据传入的<code>@ConfigurationProperties</code>注解和<code>validators</code>校验器来创建不同的<code>BindHandler</code>具体实现类：</p>
<ol>
<li>首先<code>new</code>一个<code>IgnoreTopLevelConverterNotFoundBindHandler</code>作为默认的<code>BindHandler</code>;</li>
<li>若<code>@ConfigurationProperties</code>注解的属性<code>ignoreInvalidFields</code>值为<code>true</code>，那么再<code>new</code>一个<code>IgnoreErrorsBindHandler</code>对象，把刚才新建的<code>IgnoreTopLevelConverterNotFoundBindHandler</code>对象作为构造参数传入赋值给<code>AbstractBindHandler</code>父类的<code>parent</code>属性；</li>
<li>若<code>@ConfigurationProperties</code>注解的属性<code>ignoreUnknownFields</code>值为<code>false</code>，那么再<code>new</code>一个<code>UnboundElementsSourceFilter</code>对象，把之前构造的<code>BindHandler</code>对象作为构造参数传入赋值给<code>AbstractBindHandler</code>父类的<code>parent</code>属性；</li>
<li>……以此类推，前一个<code>handler</code>对象作为后一个<code>hangdler</code>对象的构造参数，就这样利用<code>AbstractBindHandler</code>父类的<code>parent</code>属性将每一个<code>handler</code>链起来，最后再得到最终构造的<code>handler</code>。</li>
</ol>
<blockquote>
<p><strong>GET技巧</strong>：上面的这个设计模式是不是很熟悉，这个就是<strong>责任链模式</strong>。我们学习源码，同时也是学习别人怎么熟练运用设计模式。责任链模式的应用案例有很多，比如<code>Dubbo</code>的各种<code>Filter</code>们（比如<code>AccessLogFilter</code>是用来记录服务的访问日志的，<code>ExceptionFilter</code>是用来处理异常的…），我们一开始学习java web时的<code>Servlet</code>的<code>Filter</code>,<code>MyBatis</code>的<code>Plugin</code>们以及<code>Netty</code>的<code>Pipeline</code>都采用了责任链模式。</p>
</blockquote>
<p>我们了解了<code>BindHandler</code>的作用后，再来紧跟主线，看属性绑定是如何绑定的？</p>
<h3 id="获取Binder对象用于进行属性绑定"><a href="#获取Binder对象用于进行属性绑定" class="headerlink" title="获取Binder对象用于进行属性绑定"></a>获取Binder对象用于进行属性绑定</h3><p>这里接8 ConfigurationPropertiesBinder节代码中标注<code>【4】</code>的主线代码<code>getBinder().bind(annotation.prefix(), target, bindHandler);</code>.</p>
<p>可以看到这句代码主要做了两件事：</p>
<ol>
<li>调用<code>getBinder</code>方法获取用于属性绑定的<code>Binder</code>对象；</li>
<li>调用<code>Binder</code>对象的<code>bind</code>方法进行外部属性绑定到<code>@ConfigurationProperties</code>注解的<code>XxxProperties</code>类的属性上。</li>
</ol>
<p>那么我们先看下<code>getBinder</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationPropertiesBinder.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Binder <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Binder是一个能绑定ConfigurationPropertySource的容器对象</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.binder == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 新建一个Binder对象，这个binder对象封装了ConfigurationPropertySources，</span></span><br><span class="line">		<span class="comment">// PropertySourcesPlaceholdersResolver，ConversionService和PropertyEditorInitializer对象</span></span><br><span class="line">		<span class="keyword">this</span>.binder = <span class="keyword">new</span> Binder(getConfigurationPropertySources(), <span class="comment">// 将PropertySources对象封装成SpringConfigurationPropertySources对象并返回</span></span><br><span class="line">				getPropertySourcesPlaceholdersResolver(), getConversionService(), <span class="comment">// 将PropertySources对象封装成PropertySourcesPlaceholdersResolver对象并返回，从容器中获取到ConversionService对象</span></span><br><span class="line">				getPropertyEditorInitializer()); <span class="comment">// 得到Consumer&lt;PropertyEditorRegistry&gt;对象，这些初始化器用来配置property editors，property editors通常可以用来转换值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回binder</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.binder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>Binder</code>对象封装了<code>ConfigurationPropertySources</code>,<code>PropertySourcesPlaceholdersResolver</code>,<code>ConversionService</code>和<code>PropertyEditorInitializer</code>这四个对象，<code>Binder</code>对象封装了这四个哥们肯定是在后面属性绑定逻辑中会用到，先看下这四个对象是干嘛的：</p>
<ul>
<li><code>ConfigurationPropertySources</code>:外部配置文件的属性源，由<code>ConfigFileApplicationListener</code>监听器负责触发读取；</li>
<li><code>PropertySourcesPlaceholdersResolver</code>:解析属性源中的占位符<code>$&#123;&#125;</code>；</li>
<li><code>ConversionService</code>:对属性类型进行转换</li>
<li><code>PropertyEditorInitializer</code>:用来配置<code>property editors</code></li>
</ul>
<p>那么，我们获取了<code>Binder</code>属性绑定器后，再来看下它的<code>bind</code>方法是如何执行属性绑定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">BindResult&lt;T&gt; <span class="title">bind</span><span class="params">(String name, Bindable&lt;T&gt; target, BindHandler handler)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ConfigurationPropertyName.of(name)：将name（这里指属性前缀名）封装到ConfigurationPropertyName对象中</span></span><br><span class="line">	<span class="comment">// 将外部配置属性绑定到目标对象target中</span></span><br><span class="line">	<span class="keyword">return</span> bind(ConfigurationPropertyName.of(name), target, handler); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">BindResult&lt;T&gt; <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">		BindHandler handler)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(name, <span class="string">&quot;Name must not be null&quot;</span>);</span><br><span class="line">	Assert.notNull(target, <span class="string">&quot;Target must not be null&quot;</span>);</span><br><span class="line">	handler = (handler != <span class="keyword">null</span>) ? handler : BindHandler.DEFAULT;</span><br><span class="line">	<span class="comment">// Context是Binder的内部类，实现了BindContext，Context可以理解为Binder的上下文，可以用来获取binder的属性比如Binder的sources属性</span></span><br><span class="line">	Context context = <span class="keyword">new</span> Context();</span><br><span class="line">	<span class="comment">// 进行属性绑定，并返回绑定属性后的对象bound，注意bound的对象类型是T，T就是@ConfigurationProperties注解的类比如ServerProperties</span></span><br><span class="line">	<span class="comment">/********【主线，重点关注】************/</span></span><br><span class="line">	T bound = bind(name, target, handler, context, <span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">// 将刚才返回的bound对象封装到BindResult对象中并返回</span></span><br><span class="line">	<span class="keyword">return</span> BindResult.of(bound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中首先创建了一个<code>Context</code>对象，<code>Context</code>是<code>Binder</code>的内部类，为<code>Binder</code>的上下文，利用<code>Context</code>上下文可以获取<code>Binder</code>的属性比如获取<code>Binder</code>的<code>sources</code>属性值并绑定到<code>XxxProperties</code>属性中。然后我们再紧跟主线看下<code>bind(name, target, handler, context, false)</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">		BindHandler handler, Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 清空Binder的configurationProperty属性值</span></span><br><span class="line">	context.clearConfigurationProperty(); </span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		<span class="comment">// 【1】调用BindHandler的onStart方法，执行一系列的责任链对象的该方法</span></span><br><span class="line">		target = handler.onStart(name, target, context);</span><br><span class="line">		<span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="comment">// 【2】调用bindObject方法对Bindable对象target的属性进行绑定外部配置的值，并返回赋值给bound对象。</span></span><br><span class="line">		<span class="comment">// 举个栗子：比如设置了server.port=8888,那么该方法最终会调用Binder.bindProperty方法，最终返回的bound的value值为8888</span></span><br><span class="line">		<span class="comment">/************【主线：重点关注】***********/</span></span><br><span class="line">		Object bound = bindObject(name, target, handler, context, </span><br><span class="line">				allowRecursiveBinding);</span><br><span class="line">		<span class="comment">// 【3】封装handleBindResult对象并返回，注意在handleBindResult的构造函数中会调用BindHandler的onSucess，onFinish方法</span></span><br><span class="line">		<span class="keyword">return</span> handleBindResult(name, target, handler, context, bound); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">return</span> handleBindError(name, target, handler, context, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的注释已经非常详细，这里不再详述。我们接着紧跟主线来看看<code>bindObject</code>方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Object <span class="title">bindObject</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">		BindHandler handler, Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从propertySource中的配置属性，获取ConfigurationProperty对象property即application.properties配置文件中若有相关的配置的话，</span></span><br><span class="line">	<span class="comment">// 那么property将不会为null。举个栗子：假如你在配置文件中配置了spring.profiles.active=dev，那么相应property值为dev；否则为null</span></span><br><span class="line">	ConfigurationProperty property = findProperty(name, context);</span><br><span class="line">	<span class="comment">// 若property为null，则不会执行后续的属性绑定相关逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (property == <span class="keyword">null</span> &amp;&amp; containsNoDescendantOf(context.getSources(), name)) &#123;</span><br><span class="line">		<span class="comment">// 如果property == null，则返回null</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据target类型获取不同的Binder，可以是null（普通的类型一般是Null）,MapBinder,CollectionBinder或ArrayBinder</span></span><br><span class="line">	AggregateBinder&lt;?&gt; aggregateBinder = getAggregateBinder(target, context);</span><br><span class="line">	<span class="comment">// 若aggregateBinder不为null比如配置了spring.profiles属性（当然包括其子属性比如spring.profiles.active等）</span></span><br><span class="line">	<span class="keyword">if</span> (aggregateBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 若aggregateBinder不为null，则调用bindAggregate并返回绑定后的对象</span></span><br><span class="line">		<span class="keyword">return</span> bindAggregate(name, target, handler, context, aggregateBinder);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若property不为null</span></span><br><span class="line">	<span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 绑定属性到对象中，比如配置文件中设置了server.port=8888，那么将会最终调用bindProperty方法进行属性设置</span></span><br><span class="line">			<span class="keyword">return</span> bindProperty(target, context, property);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ConverterNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// We might still be able to bind it as a bean</span></span><br><span class="line">			Object bean = bindBean(name, target, handler, context,</span><br><span class="line">					allowRecursiveBinding);</span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 只有@ConfigurationProperties注解的类进行外部属性绑定才会走这里</span></span><br><span class="line">	<span class="comment">/***********************【主线，重点关注】****************************/</span></span><br><span class="line">	<span class="keyword">return</span> bindBean(name, target, handler, context, allowRecursiveBinding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上代码中可以看到<code>bindObject</code>中执行属性绑定的逻辑会根据不同的属性类型进入不同的绑定逻辑中，举个栗子：</p>
<ol>
<li><code>application.properties</code>配置文件中配置了<code>spring.profiles.active=dev</code>的话，那么将会进入<code>return bindAggregate(name, target, handler, context, aggregateBinder);</code>这个属性绑定的代码逻辑；</li>
<li><code>application.properties</code>配置文件中配置了<code>server.port=8081</code>的话，那么将会进入<code>return bindBean(name, target, handler, context, allowRecursiveBinding);</code>的属性绑定的逻辑。</li>
</ol>
<p>因此我们再次紧跟主线，进入<code>@ConfigurationProperties</code>注解的<code>XxxProperties</code>类的属性绑定逻辑中的<code>bindBean</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Binder.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">bindBean</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target, // name指的是ConfigurationProperties的前缀名</span></span></span><br><span class="line"><span class="function"><span class="params">		BindHandler handler, Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里做一些ConfigurationPropertyState的相关检查</span></span><br><span class="line">	<span class="keyword">if</span> (containsNoDescendantOf(context.getSources(), name)</span><br><span class="line">			|| isUnbindableBean(name, target, context)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;<span class="comment">// 这里新建一个BeanPropertyBinder的实现类对象，注意这个对象实现了bindProperty方法</span></span><br><span class="line">	BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -&gt; bind(</span><br><span class="line">			name.append(propertyName), propertyTarget, handler, context, <span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * (propertyName, propertyTarget) -&gt; bind(</span></span><br><span class="line"><span class="comment">	 * 				name.append(propertyName), propertyTarget, handler, context, false);</span></span><br><span class="line"><span class="comment">	 * 	等价于</span></span><br><span class="line"><span class="comment">	 * 	new BeanPropertyBinder() &#123;</span></span><br><span class="line"><span class="comment">	 *		Object bindProperty(String propertyName, Bindable&lt;?&gt; target)&#123;</span></span><br><span class="line"><span class="comment">	 *			bind(name.append(propertyName), propertyTarget, handler, context, false);</span></span><br><span class="line"><span class="comment">	 *		&#125;</span></span><br><span class="line"><span class="comment">	 * 	&#125;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// type类型即@ConfigurationProperties注解标注的XxxProperties类</span></span><br><span class="line">	Class&lt;?&gt; type = target.getType().resolve(Object.class);</span><br><span class="line">	<span class="keyword">if</span> (!allowRecursiveBinding &amp;&amp; context.hasBoundBean(type)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里应用了java8的lambda语法，作为没怎么学习java8的lambda语法的我，不怎么好理解下面的逻辑，哈哈</span></span><br><span class="line">	<span class="comment">// 真正实现将外部配置属性绑定到@ConfigurationProperties注解的XxxProperties类的属性中的逻辑应该就是在这句lambda代码了</span></span><br><span class="line">	<span class="comment">/*******************【主线】***************************/</span></span><br><span class="line">	<span class="keyword">return</span> context.withBean(type, () -&gt; &#123;</span><br><span class="line">		Stream&lt;?&gt; boundBeans = BEAN_BINDERS.stream()</span><br><span class="line">				.map((b) -&gt; b.bind(name, target, context, propertyBinder));</span><br><span class="line">		<span class="keyword">return</span> boundBeans.filter(Objects::nonNull).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">// 根据上面的lambda语句翻译如下：</span></span><br><span class="line">	<span class="comment">/** 这里的T指的是各种属性绑定对象，比如ServerProperties</span></span><br><span class="line"><span class="comment">	 * return context.withBean(type, new Supplier&lt;T&gt;() &#123;</span></span><br><span class="line"><span class="comment">	 * 	T get() &#123;</span></span><br><span class="line"><span class="comment">	 * 		Stream&lt;?&gt; boundBeans = BEAN_BINDERS.stream()</span></span><br><span class="line"><span class="comment">	 * 					.map((b) -&gt; b.bind(name, target, context, propertyBinder));</span></span><br><span class="line"><span class="comment">	 * 			return boundBeans.filter(Objects::nonNull).findFirst().orElse(null);</span></span><br><span class="line"><span class="comment">	 *        &#125;</span></span><br><span class="line"><span class="comment">	 *  &#125;);</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码中，我们追根究底来到了外部配置属性绑定到<code>XxxProperties</code>类属性中的比较底层的代码了，可以看到属性绑定的逻辑应该就在上面代码标注<code>【主线】</code>的<code>lambda</code>代码处了。这里就不再详述了，因为这个属于SpringBoot的属性绑定<code>Binder</code>的范畴，<code>Binder</code>相关类是SpringBoot2.0才出现的，即对之前的属性绑定相关代码进行推翻重写了。属性绑定相关的源码也比较多，后续有需要再另开一篇来分析探究吧。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>好了，外部配置属性值是如何被绑定到<code>XxxProperties</code>类属性上的源码分析就到此结束了，不知自己表述清楚没，重要步骤现总结下：</p>
<ol>
<li>首先是<code>@EnableConfigurationProperties</code>注解<code>import</code>了<code>EnableConfigurationPropertiesImportSelector</code>后置处理器；</li>
<li><code>EnableConfigurationPropertiesImportSelector</code>后置处理器又向<code>Spring</code>容器中注册了<code>ConfigurationPropertiesBeanRegistrar</code>和<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>这两个<code>bean</code>；</li>
<li>其中<code>ConfigurationPropertiesBeanRegistrar</code>向<code>Spring</code>容器中注册了<code>XxxProperties</code>类型的<code>bean</code>；<code>ConfigurationPropertiesBindingPostProcessorRegistrar</code>向<code>Spring</code>容器中注册了<code>ConfigurationBeanFactoryMetadata</code>和<code>ConfigurationPropertiesBindingPostProcessor</code>两个后置处理器；</li>
<li><code>ConfigurationBeanFactoryMetadata</code>后置处理器在初始化<code>bean</code> <code>factory</code>时将<code>@Bean</code>注解的元数据存储起来，以便在后续的外部配置属性绑定的相关逻辑中使用；</li>
<li><code>ConfigurationPropertiesBindingPostProcessor</code>后置处理器将外部配置属性值绑定到<code>XxxProperties</code>类属性的逻辑委托给<code>ConfigurationPropertiesBinder</code>对象，然后<code>ConfigurationPropertiesBinder</code>对象又最终将属性绑定的逻辑委托给<code>Binder</code>对象来完成。</li>
</ol>
<h1 id="SpringBoot的启动流程是怎样的"><a href="#SpringBoot的启动流程是怎样的" class="headerlink" title="SpringBoot的启动流程是怎样的"></a>SpringBoot的启动流程是怎样的</h1><p><code>SpringApplication</code>类是用来启动SpringBoot项目的，可以在java的<code>main</code>方法中启动，目前我们知道这些就足够了。下面看下<code>SpringApplication.run(MainApplication.class, args);</code>这句代码的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run方法是一个静态方法，用于启动SpringBoot</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,</span></span></span><br><span class="line"><span class="function"><span class="params">		String... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 继续调用静态的run方法</span></span><br><span class="line">	<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的静态<code>run</code>方法里又继续调用另一个静态<code>run</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// run方法是一个静态方法，用于启动SpringBoot</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">		String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构建一个SpringApplication对象，并调用其run方法来启动</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，可以看到构建了一个<code>SpringApplication</code>对象，然后再调用其<code>run</code>方法来启动SpringBoot项目。关于<code>SpringApplication</code>对象是如何构建的，我们后面再分析，现在直接来看下启动流程的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// new 一个StopWatch用于统计run启动过程花了多少时间</span></span><br><span class="line">	StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">	<span class="comment">// 开始计时</span></span><br><span class="line">	stopWatch.start();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// exceptionReporters集合用来存储异常报告器，用来报告SpringBoot启动过程的异常</span></span><br><span class="line">	Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">// 配置headless属性，即“java.awt.headless”属性，默认为ture</span></span><br><span class="line">	<span class="comment">// 其实是想设置该应用程序,即使没有检测到显示器,也允许其启动.对于服务器来说,是不需要显示器的,所以要这样设置.</span></span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	<span class="comment">// 【1】从spring.factories配置文件中加载到EventPublishingRunListener对象并赋值给SpringApplicationRunListeners</span></span><br><span class="line">	<span class="comment">// EventPublishingRunListener对象主要用来发射SpringBoot启动过程中内置的一些生命周期事件，标志每个不同启动阶段</span></span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	<span class="comment">// 启动SpringApplicationRunListener的监听，表示SpringApplication开始启动。</span></span><br><span class="line">	<span class="comment">// 》》》》》发射【ApplicationStartingEvent】事件</span></span><br><span class="line">	listeners.starting();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 创建ApplicationArguments对象，封装了args参数</span></span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">				args);</span><br><span class="line">		<span class="comment">// 【2】准备环境变量，包括系统变量，环境变量，命令行参数，默认变量，servlet相关配置变量，随机值，</span></span><br><span class="line">		<span class="comment">// JNDI属性值，以及配置文件（比如application.properties）等，注意这些环境变量是有优先级的</span></span><br><span class="line">		<span class="comment">// 》》》》》发射【ApplicationEnvironmentPreparedEvent】事件</span></span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">				applicationArguments);</span><br><span class="line">		<span class="comment">// 配置spring.beaninfo.ignore属性，默认为true，即跳过搜索BeanInfo classes.</span></span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		<span class="comment">// 【3】控制台打印SpringBoot的bannner标志</span></span><br><span class="line">		Banner printedBanner = printBanner(environment);</span><br><span class="line">		<span class="comment">// 【4】根据不同类型创建不同类型的spring applicationcontext容器</span></span><br><span class="line">		<span class="comment">// 因为这里是servlet环境，所以创建的是AnnotationConfigServletWebServerApplicationContext容器对象</span></span><br><span class="line">		context = createApplicationContext();</span><br><span class="line">		<span class="comment">// 【5】从spring.factories配置文件中加载异常报告期实例，这里加载的是FailureAnalyzers</span></span><br><span class="line">		<span class="comment">// 注意FailureAnalyzers的构造器要传入ConfigurableApplicationContext，因为要从context中获取beanFactory和environment</span></span><br><span class="line">		exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">				SpringBootExceptionReporter.class,</span><br><span class="line">				<span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context); // ConfigurableApplicationContext是AnnotationConfigServletWebServerApplicationContext的父接口</span><br><span class="line">		<span class="comment">// 【6】为刚创建的AnnotationConfigServletWebServerApplicationContext容器对象做一些初始化工作，准备一些容器属性值等</span></span><br><span class="line">		<span class="comment">// 1）为AnnotationConfigServletWebServerApplicationContext的属性AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner设置environgment属性</span></span><br><span class="line">		<span class="comment">// 2）根据情况对ApplicationContext应用一些相关的后置处理，比如设置resourceLoader属性等</span></span><br><span class="line">		<span class="comment">// 3）在容器刷新前调用各个ApplicationContextInitializer的初始化方法，ApplicationContextInitializer是在构建SpringApplication对象时从spring.factories中加载的</span></span><br><span class="line">		<span class="comment">// 4）》》》》》发射【ApplicationContextInitializedEvent】事件，标志context容器被创建且已准备好</span></span><br><span class="line">		<span class="comment">// 5）从context容器中获取beanFactory，并向beanFactory中注册一些单例bean，比如applicationArguments，printedBanner</span></span><br><span class="line">		<span class="comment">// 6）TODO 加载bean到application context，注意这里只是加载了部分bean比如mainApplication这个bean，大部分bean应该是在AbstractApplicationContext.refresh方法中被加载？这里留个疑问先</span></span><br><span class="line">		<span class="comment">// 7）》》》》》发射【ApplicationPreparedEvent】事件，标志Context容器已经准备完成</span></span><br><span class="line">		prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">				printedBanner);</span><br><span class="line">		<span class="comment">// 【7】刷新容器，这一步至关重要，以后会在分析Spring源码时详细分析，主要做了以下工作：</span></span><br><span class="line">		<span class="comment">// 1）在context刷新前做一些准备工作，比如初始化一些属性设置，属性合法性校验和保存容器中的一些早期事件等；</span></span><br><span class="line">		<span class="comment">// 2）让子类刷新其内部bean factory,注意SpringBoot和Spring启动的情况执行逻辑不一样</span></span><br><span class="line">		<span class="comment">// 3）对bean factory进行配置，比如配置bean factory的类加载器，后置处理器等</span></span><br><span class="line">		<span class="comment">// 4）完成bean factory的准备工作后，此时执行一些后置处理逻辑，子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置</span></span><br><span class="line">		<span class="comment">// 在这一步，所有的bean definitions将会被加载，但此时bean还不会被实例化</span></span><br><span class="line">		<span class="comment">// 5）执行BeanFactoryPostProcessor的方法即调用bean factory的后置处理器：</span></span><br><span class="line">		<span class="comment">// BeanDefinitionRegistryPostProcessor（触发时机：bean定义注册之前）和BeanFactoryPostProcessor（触发时机：bean定义注册之后bean实例化之前）</span></span><br><span class="line">		<span class="comment">// 6）注册bean的后置处理器BeanPostProcessor，注意不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</span></span><br><span class="line">		<span class="comment">// 7）初始化国际化MessageSource相关的组件，比如消息绑定，消息解析等</span></span><br><span class="line">		<span class="comment">// 8）初始化事件广播器，如果bean factory没有包含事件广播器，那么new一个SimpleApplicationEventMulticaster广播器对象并注册到bean factory中</span></span><br><span class="line">		<span class="comment">// 9）AbstractApplicationContext定义了一个模板方法onRefresh，留给子类覆写，比如ServletWebServerApplicationContext覆写了该方法来创建内嵌的tomcat容器</span></span><br><span class="line">		<span class="comment">// 10）注册实现了ApplicationListener接口的监听器，之前已经有了事件广播器，此时就可以派发一些early application events</span></span><br><span class="line">		<span class="comment">// 11）完成容器bean factory的初始化，并初始化所有剩余的单例bean。这一步非常重要，一些bean postprocessor会在这里调用。</span></span><br><span class="line">		<span class="comment">// 12）完成容器的刷新工作，并且调用生命周期处理器的onRefresh()方法，并且发布ContextRefreshedEvent事件</span></span><br><span class="line">		refreshContext(context);</span><br><span class="line">		<span class="comment">// 【8】执行刷新容器后的后置处理逻辑，注意这里为空方法</span></span><br><span class="line">		afterRefresh(context, applicationArguments);</span><br><span class="line">		<span class="comment">// 停止stopWatch计时</span></span><br><span class="line">		stopWatch.stop();</span><br><span class="line">		<span class="comment">// 打印日志</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">					.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 》》》》》发射【ApplicationStartedEvent】事件，标志spring容器已经刷新，此时所有的bean实例都已经加载完毕</span></span><br><span class="line">		listeners.started(context);</span><br><span class="line">		<span class="comment">// 【9】调用ApplicationRunner和CommandLineRunner的run方法，实现spring容器启动后需要做的一些东西比如加载一些业务数据等</span></span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 【10】若启动过程中抛出异常，此时用FailureAnalyzers来报告异常</span></span><br><span class="line">	<span class="comment">// 并》》》》》发射【ApplicationFailedEvent】事件，标志SpringBoot启动失败</span></span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 》》》》》发射【ApplicationReadyEvent】事件，标志SpringApplication已经正在运行即已经成功启动，可以接收服务请求了。</span></span><br><span class="line">		listeners.running(context);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若出现异常，此时仅仅报告异常，而不会发射任何事件</span></span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 【11】最终返回容器</span></span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码就是SpringBoot的启动流程了，其中注释也非常详细，主要步骤也已经标注<code>【x】</code>，现将主要步骤总结如下：</p>
<ol>
<li>从<code>spring.factories</code>配置文件中<strong>加载<code>EventPublishingRunListener</code>对象</strong>，该对象拥有<code>SimpleApplicationEventMulticaster</code>属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;</li>
<li><strong>准备环境变量</strong>，包括系统变量，环境变量，命令行参数，默认变量，<code>servlet</code>相关配置变量，随机值以及配置文件（比如<code>application.properties</code>）等;</li>
<li>控制台<strong>打印SpringBoot的<code>bannner</code>标志</strong>；</li>
<li><strong>根据不同类型环境创建不同类型的<code>applicationcontext</code>容器</strong>，因为这里是<code>servlet</code>环境，所以创建的是<code>AnnotationConfigServletWebServerApplicationContext</code>容器对象；</li>
<li>从<code>spring.factories</code>配置文件中<strong>加载<code>FailureAnalyzers</code>对象</strong>,用来报告SpringBoot启动过程中的异常；</li>
<li><strong>为刚创建的容器对象做一些初始化工作</strong>，准备一些容器属性值等，对<code>ApplicationContext</code>应用一些相关的后置处理和调用各个<code>ApplicationContextInitializer</code>的初始化方法来执行一些初始化逻辑等；</li>
<li><strong>刷新容器</strong>，这一步至关重要。比如调用<code>bean factory</code>的后置处理器，注册<code>BeanPostProcessor</code>后置处理器，初始化事件广播器且广播事件，初始化剩下的单例<code>bean</code>和SpringBoot创建内嵌的<code>Tomcat</code>服务器等等重要且复杂的逻辑都在这里实现，主要步骤可见代码的注释，关于这里的逻辑会在以后的spring源码分析专题详细分析；</li>
<li><strong>执行刷新容器后的后置处理逻辑</strong>，注意这里为空方法；</li>
<li><strong>调用<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的run方法</strong>，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>
<li><strong>报告启动异常</strong>，即若启动过程中抛出异常，此时用<code>FailureAnalyzers</code>来报告异常;</li>
<li>最终<strong>返回容器对象</strong>，这里调用方法没有声明对象来接收。</li>
</ol>
<p>当然在SpringBoot启动过程中，每个不同的启动阶段会分别发射不同的内置生命周期事件，比如在准备<code>environment</code>前会发射<code>ApplicationStartingEvent</code>事件，在<code>environment</code>准备好后会发射<code>ApplicationEnvironmentPreparedEvent</code>事件，在刷新容器前会发射<code>ApplicationPreparedEvent</code>事件等，总之SpringBoot总共内置了7个生命周期事件，除了标志SpringBoot的不同启动阶段外，同时一些监听器也会监听相应的生命周期事件从而执行一些启动初始化逻辑。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/Spring-Boot/">Spring Boot</a></div><div class="post_share"><div class="social-share" data-image="/blogImg/spring%20boot%E6%BA%90%E7%A0%81%E6%A8%A1%E5%9D%97.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/Wechatpay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/Wechatpay.jpeg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpeg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/09/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"><img class="next-cover" src="/blogImg/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式总结</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wangpengyu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html>